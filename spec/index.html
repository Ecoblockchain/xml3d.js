<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>XML3D 5.0 Specification</title>
    <script src='http://www.w3.org/Tools/respec/respec-w3c-common' async class='remove'></script>
    <link rel="stylesheet" href="xml3d-spec.css">

    <script class='remove'>
        var respecConfig = {
            // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
            specStatus: "unofficial",

            // the specification's short name, as in http://www.w3.org/TR/short-name/
            shortName: "xml3d",

            // if your specification has a subtitle that goes below the main
            // formal title, define it here
            subtitle: "Interactive 3D Graphics for the Web",

            // if you wish the publication date to be other than today, set this
            publishDate: "",

            // if the specification's copyright date is a range of years, specify
            // the start date here:
            // copyrightStart: "2005",

            // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
            // and its maturity status
            // previousPublishDate:  "1977-03-15",
            // previousMaturity:  "WD",

            // if there a publicly available Editor's Draft, this is the link
            // edDraftURI: "http://dev.w3.org/2009/dap/ReSpec.js/documentation.html",
            previousURI: "http://www.xml3d.org/xml3d/specification/0.4.3/",

            // editors, add as many as you like
            // only "name" is required
            editors: [{
                name: "Kristian Sons"
            }, {
                name: "Christian Schlinkmann"
            }],

            // authors, add as many as you like.
            // This is optional, uncomment if you have authors as well as editors.
            // only "name" is required. Same format as editors.

            authors: [{
                name: "Felix Klein",
                company: "Intel Visual Computing Institute",
                companyURL: "http://www.intel-vci.uni-saarland.de/"
            }, {
                name: "Kristian Sons", company: "DFKI", companyURL: "http://www.dfki.de/"
            }, {
                name: "Christian Schlinkmann", company: "DFKI", companyURL: "http://www.dfki.de/"
            }
            ],

            // name of the WG
            wg: "Declarative 3D Community Group",

            // URI of the public WG page
            wgURI: "http://www.w3.org/community/declarative3d/",

            // name (without the @w3c.org) of the public mailing to which comments are due
            wgPublicList: "public-declarative3d",

            // URI of the patent status for this WG, for Rec-track documents
            // !!!! IMPORTANT !!!!
            // This is important for Rec-track documents, do not copy a patent URI from a random
            // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
            // Team Contact.
            wgPatentURI: "http://www.w3.org/community/about/agreements/cla/"
        };
    </script>
</head>
<body>
<section id='abstract'>
    This document defines the 5th revision of XML3D, an extension to HTML5 for describing interactive 3D scenes.
</section>

<section>
    <h2>Introduction</h2>
    <section>
        <h3>Motivation</h3>

        <p>The idea of adding virtual 3D worlds to the web has a long history:
            In 1994, Dave Ragget proposed a platform independent 3D scene description based on web technologies as
            “mechanisms
            for people to share VR models on a global basis”.
            Ragget also proposed to describe the structure of the virtual world on a high abstraction level based on the
            experiences of SGML and HTML.
            In the same year, Pesce et al. proposed extending “HTML to describe both geometry and space”.</p>

        <p>However, the developers of the resulting VRML standard decided against designing VRML as an extension to
            HTML.
            As a result, Web3D never took off until Vladimir Vukićević prototyped an OpenGL-based API for the HTML
            <code>&lt;canvas&gt;</code>
            element in 2006.
            This idea finally led to [[WebGL]].</p>

        <p>
            Although WebGL is a great technology and paved the way for accelerated 3D graphics in the browser, it also
            comes
            with some disadvantages that are addressed by XML3D:
            First, it is only loosely coupled with other W3C technologies such as HTML, CSS, DOM scripting and events.
            As a consequence, web developers need to learn new concepts and WebGL-based libraries can not interoperate
            with
            HTML and DOM libraries such as jQuery.
            Secondly, WebGL is tied to OpenGL and does not take other algorithms and APIs into account. For instance,
            the
            definition of pipeline shaders is too specific and too low-level to use for ray tracing or
            global-illumination algorithms.
        </p>

        <p>
            Thus, XML3D picks up the idea of a platform independent 3D scene description on a higher abstraction level
            on the
            basis of HTML (and yes, XML3D is a stupid name for that).
            At the same time, it takes the features of modern graphics APIs into account and exposes data processing and
            shading capabilities to the user, which can be mapped to the GPU pipeline.
            Despite these capabilities it can still be rendered with arbitrary rendering algorithms.
        </p>

        <p>
            We do not expect that browser vendors will implement XML3D natively in the near future.
            The main motivation of this specification is to enable people to share their 3D assets including 3D models,
            materials and animations and to easily create stunning 3D web applications.
            Therefore, XML3D is accompanied with a <a href="https://github.com/xml3d/xml3d.js/">reference
            application</a>, a
            polyfill that uses WebGL and JavaScript to emulate native XML3D support.
            As a result, XML3D is fully usable today and various applications already exist.
        </p>

        <p>
            However, having said that, we expect that a native implementation of XML3D would come with a series of
            benefits:
            Browsers could render scenes with advanced rendering algorithms or render the scene or parts of the scene as
            a
            service in the cloud.
            The higher abstraction level gives implementations opportunities to optimize performance and to provide
            advanced
            debugging facilities.
            A native renderer can also reason about the scene's content and changes and - as a result - driving VR
            applications
            would be much easier.
        </p>
    </section>
    <section>
        <h3>About XML3D</h3>

        <p>This specification defines the features and syntax of XML3D.</p>

        <p>XML3D is a language for describing interactive 3D scenes.
            Although the name may suggest otherwise, XML3D is not an XML language.
            Instead it is designed as an extension to [[HTML5]]. Consequently, XML3D defines an abstract language and
            APIs for
            interacting with the 3D scene.
            Similar to HTML5, the concrete syntax of XML3D can be either the [[HTML5]] syntax or the [[XML]] syntax.</p>

        <p>XML3D reuses concepts from HTML5: [[DOM]] scripting and [[UIEvents]] allow easy creation of interactive 3D
            scenes.
            [[CSS2]] can be used to define <a href="#h-style">styling properties</a> for XML3D elements such as
            transformations
            or visibility.
            Hence, XML3D is tightly integrated into the W3C technology stack.</p>

        <p>On the other hand, XML3D introduces some novel concepts.
            XML3D introduces a <a href="#h-generic-data-model">generic data model</a> to define arbitrarily named and
            typed
            parameters.
            XML3D has a dataflow graph concept in order to describe data processing within the HTML document.
            Finally, it supports programmable materials based on JavaScript.
            These concepts are essential to gain a higher flexibility compared to previous declarative 3D scene
            descriptions
            (e.g. VRML or X3D).</p>

        <p>XML3D is platform independent, i.e. an XML3D scene description can be rendered using arbitrary rendering
            algorithms. Thus, XML3D can not only be rendered with
            various flavours of GPU rasterization (forward rendering, deferred rendering, etc),
            but also with ray tracing and rendering algorithms taking global illumination into account (e.g. Monte Carlo
            path
            tracing).
            Similar to HTML, XML3D describes <i>what</i> should be rendered rather than <i>how</i> it should be
            rendered.
        </p>

        <p>XML3D is a lean low-level 3D scene description. Convenience functionality found in other approaches can be
            implemented on top of XML3D, for instance using scripting and concepts such as [[custom-elements]].</p>
    </section>
    <section>
        <h3>Compatibility with Other Standards Efforts</h3>
        XML3D leverages and integrates with other W3C specifications and standards efforts.
        By leveraging and conforming to other standards, XML3D becomes more powerful and makes it easier for users to
        learn
        how to incorporate XML3D into their Web sites.

        <ul>
            <li>XML3D is an extension to [[HTML5]].</li>
            <li>XML3D reuses [[HTML5]] elements, e.g. the <code>&lt;img&gt;</code> element to define texture data.</li>
            <li>XML3D content can be styled with [[CSS2]], i.e. XML3D supports all <a>relevant style properties</a>.
            </li>
            <li>XML3D defines [[DOM]] interfaces for scripting. All XML3D elements derive from the
                <code>HTMLElement</code>
                DOM interface.
            </li>
            <li>XML3D leverages [[UIEvents]] as its event system and supports all relevant events available in HTML.
                Additionally,
                it supports all relevant event attributes.
            </li>
            <li>XML3D adopts the <code>&lt;defs&gt;</code> element from [[SVG]].</li>
        </ul>

        XML3D uses [[URI]]s, in particular URNs for identifiying predefined models and URLs for identifing resources in
        the
        same or in external documents.
    </section>
</section>

<section>
    <h2>Concepts</h2>

    <section>
        <h3>Generic data model</h3>
        HTML elements can be parametrized using HTML attributes or CSS properties. In graphics we need, however, the possibility to define sets of arbitrarily named and typed parameters.
        Additionally, these parameters may be very long, for instance the positions of a mesh. Hence, we introduce a generic data model for XML3D, which is used consistently throughout XML3D's
        abstract model.

        <p>XML3D's generic data model provides means to share and compose data between data consumers such as the <a>mesh element</a>, <a>light element</a>, <a>view element</a>, and <a>material element</a>.
        It is also the basis for the <a href="#dataflow-graph">dataflow graph</a> concept and for programmable materials with shade.js, which both require arbritraily typed and named parameters.</p>


       All <a href="#data-elements">data elements</a> output a table of named entries. This table is composed
          <ul>
            <li>from mark-up, i.e. from <a href="#value-elements">value elements</a> and </li>
            <li>from references to an
            <ul>
              <li>intra-document <a>data element</a></li>
              <li>external resource</li>
            </ul>
            </li>
          </ul>
      <div class="note">
        To not spoil the user experience, large parameter sets (e.g. mesh data) should never be defined inside the web page. Instead, this kind of data should be defined
        in external resources which are loaded asynchronously, e.g. in a JSON file or, more efficiently, using a container in <a href="http://xml3d.org/xml3d/papers/blast/">Blast format</a>.
      </div>

      <section>
        <h4>Mark-up</h4>
        The <a href="#value-elements">value elements</a> can be used to define data table entries directly in mark-up. This is useful for all parameters that need
        to be modified during runtime using the DOM API. <a href="#value-elements">Value elements</a> can be used to construct a reusable data source using the <a>data element</a>,
        or to parametrize a consumer element, e.g. a <a>mesh element</a>, directly.
          <pre class='example highlight'>
                &lt;data id="parameter-set"&gt;     &lt;!-- generic data container --&gt;
                    &lt;float3 name="parameter-1"&gt;1.0 0.0 0.0&lt;/float3&gt;
                    &lt;float name="parameter-2"&gt;0.5&lt;/float&gt;
                &lt;/data&gt;

                &lt;material id="material1" model="..."&gt;     &lt;!-- parameterized consumer --&gt;
                    &lt;float3 name="parameter-1"&gt;1.0 0.0 0.0&lt;/float3&gt;
                    &lt;float name="parameter-2"&gt;0.5&lt;/float&gt;
                &lt;/material&gt;
          </pre>


      </section>
      <section>
        <h4>Sequences</h4>

        <p>The generic data model allows arbitrarily long sequences of data to be defined using the <code>key</code> attribute on <a
          href="#value-elements">value elements</a>. This is useful,
          for example, to define the base data for mesh animations to be driven by Xflow <a
            href="#the-compute-operator">compute operators</a>.
        </p>
        <pre class="example highlight">
          &lt;data id="keyFrameData"&gt;
            &lt;float3 name="position" key="0" &gt;-5 0 5 ... &lt;/float3&gt;
            &lt;float3 name="normal" key="0" &gt;0 -1 0 ... &lt;/float3&gt;

            &lt;float3 name="position" key="0.1" &gt;-2.886751 2.113249 2.886751 ... &lt;/float3&gt;
            &lt;float3 name="normal" key="0.1"&gt;-0.554395 -0.620718 0.554395 ... &lt;/float3&gt;

            &lt;float3 name="position" key="0.2"&gt;-1.341089 4.649148 1.341089 ... &lt;/float3&gt;
            &lt;float3 name="normal" key="0.2"&gt;-0.696886 0.169412 0.696886 ... &lt;/float3&gt;

            &lt;float3 name="position" key="0.3" &gt;-6.158403 1.408833 6.158403 ... &lt;/float3&gt;
            &lt;float3 name="normal" key="0.3"&gt;-0.141341 -0.979819 0.141341 ... &lt;/float3&gt;

            ...
          &lt;/data&gt;
        </pre>
        <p>The above sequence of data represents the keyframes of a mesh animation. Typically a compute operator
          would then be used to interpolate between keyframes, or to
          otherwise map the sequences of data to a definite set of <code>position</code> and <code>normal</code>
          data to be rendered.</p>
      </section>

      <section>
        <h4>External resources</h4>

        For external data resources, a mapping to a data table needs to be defined which is identified via the
        internet media type [[rfc2045]] of the resource. XML3D comes with mappings for external XML3D files, and JSON files in XML3D
        format.
        In xml3d.js, additional mappings can be provide via a plug-in mechanism.
        <div class="note">
          A STL file consists of vertex positions and face normals. A mapping could define that the vertex positions are
          mapped to an entry named <code>position</code> and to per-vertex normals (requires processing) named
          <code>normal</code>, both of type <code>float3</code>. Then a <a>mesh element</a> can reference STL
          files directly:
        <pre class="highlight">
        &lt;mesh src="printable-teapot.stl"&gt;&lt;/mesh&gt;
        </pre>
          Note that defining this mapping is possible in xml3d.js via a plug-in. A plug-in for STL files is available <a
          href="https://github.com/xml3d/xml3d-stl-plugin">here</a>.
        </div>
      </section>

     <section>
        <h4>Data compositing</h4>
       Data can be shared and composed from multiple internal and external sources.
       A set of overriding rules handles cases, where entries with the same name and sequence key exits.
       <ol>
         <li>A subsequent <a href="#value-elements">value element</a> overrides previous ones.</li>
         <li>Local <a href="#value-elements">value elements</a> override referenced data sources.</li>
         <li>Entries in the output of a referenced data table override entries of a previously referenced data table.</li>
         <li>The output of a referenced data table gets evaluated with the same set of overriding rules before it is taken into account.</li>
       </ol>
       The overriding rules can be exploited to specialize more general data sources.

       <pre class="example highlight">
       &lt;data id=&quot;specularTerm&quot;&gt;
         &lt;float3 name=&quot;specularColor&quot;&gt;0.1 0.2 0.3&lt;/float3&gt;
         &lt;float name=&quot;ambientIntensity&quot;&gt;0.1&lt;/float&gt;
         &lt;float name=&quot;shininess&quot;&gt;0.2&lt;/float&gt;
         &lt;float name=&quot;shininess&quot;&gt;0.6&lt;/float&gt; &lt;!-- shininess is 0.6 according to rule 1 --&gt;
       &lt;/data&gt;

       &lt;data id=&quot;diffuseTerm&quot;&gt;
         &lt;float3 name=&quot;diffuseColor&quot;&gt;0.1 0.2 0.3&lt;/float3&gt;
         &lt;float name=&quot;ambientIntensity&quot;&gt;0.9&lt;/float&gt;
       &lt;/data&gt;

       &lt;material id=&quot;composedMaterial&quot;&gt; &lt;!-- Composing a material from multiple sources --&gt;
         &lt;data src=&quot;path/to/external/resource.xml#textureData&quot;&gt;&lt;/data&gt;
         &lt;data src=&quot;#specularTerm&quot;&gt;&lt;/data&gt;  &lt;!-- shininess is 0.6 according to rule 4 --&gt;
         &lt;data src=&quot;#diffuseTerm&quot;&gt;&lt;/data&gt;   &lt;!-- ambientIntensity is 0.9 according to rule 3 --&gt;

       &lt;/material&gt;

       &lt;material id=&quot;specializedMaterial&quot;&gt;
         &lt;data src=&quot;#specularTerm&quot;&gt;&lt;/data&gt;  &lt;!-- Reuse data from #specularTerm --&gt;
         &lt;float name=&quot;shininess&quot;&gt;0.4&lt;/float&gt; &lt;!-- shininess is 0.4 according to rule 2 --&gt;
       &lt;/material&gt;
         </pre>






      </section>
      <section>
            <h4>Filters</h4>

            <p>The generic data model defines three filters that may be applied to data through the <code>filter</code> attribute on the
                <a>data element</a> and the
                <a>dataflow element</a>. </p>

      <pre>
        filter="keep|remove(field1 [, field2...])"
        filter="rename( { newFieldName : field [, newFieldName2 : field2...] } )"
      </pre>

            <p>A filter does not change the data itself but rather influences how that data is made available to other
                elements. For example, using a <code>remove</code>
                filter does not actually remove the data from the element, it simply hides it from parent
                elements. </p>

            <p>An data element may only have one filter, if multiple filters are needed they can be applied with nested
                data elements. </p>

      <pre class="example highlight">
        &lt;data filter="keep(A,D)"&gt;
          &lt;float name="A" &gt;0&lt;/float&gt;
          &lt;float name="B" &gt;1&lt;/float&gt; &lt;!-- will be removed --&gt;
          &lt;float name="C" &gt;1&lt;/float&gt; &lt;!-- will be removed --&gt;
          &lt;float name="D" &gt;1&lt;/float&gt;
        &lt;/data&gt;

        &lt;data filter="remove(D)"&gt;
          &lt;float name="A" &gt;0&lt;/float&gt;
          &lt;float name="B" &gt;1&lt;/float&gt;
          &lt;float name="C" &gt;1&lt;/float&gt;
          &lt;float name="D" &gt;1&lt;/float&gt; &lt;!-- will be removed --&gt;
        &lt;/data&gt;

        &lt;data filter="rename( {A2 : A, B2 : B} )"&gt;
          &lt;float name="A" &gt;0&lt;/float&gt; &lt;!-- will be renamed into A2 --&gt;
          &lt;float name="B" &gt;1&lt;/float&gt; &lt;!-- will be renamed into B2 --&gt;
          &lt;float name="C" &gt;1&lt;/float&gt;
          &lt;float name="D" &gt;1&lt;/float&gt;
        &lt;/data&gt;

        &lt;data filter="keep( {A2 : A, B2 : B} )"&gt;
          &lt;float name="A" &gt;0&lt;/float&gt; &lt;!-- will be renamed into A2 --&gt;
          &lt;float name="B" &gt;1&lt;/float&gt; &lt;!-- will be renamed into B2 --&gt;
          &lt;float name="C" &gt;1&lt;/float&gt; &lt;!-- will be removed --&gt;
          &lt;float name="D" &gt;1&lt;/float&gt; &lt;!-- will be removed --&gt;
        &lt;/data&gt;

        &lt;data filter="rename( {A1 : A, A2 : A, A3: A} )"&gt;
          &lt;float name="A" &gt;0&lt;/float&gt; &lt;!-- will be provided under the names A1, A2 and A3 --&gt;
        &lt;/data&gt;
      </pre>

        </section>

    </section>
    <section>
      <h3>Dataflow graph (Xflow)</h3>

      <p>XML3D comes with a lean set of <a href="h-scene elements">scene elements</a>, in particular if compared to
        other scene descriptions.
        To describe dynamic effects in the scene XML3D provides a dataflow graph approach (Xflow), that allows arranging
        data processing operations as a graph of operations. This way, it is possible to describe complex dynamic data
        processing from basic blocks.</p>

      <p>Xflow is powerful enough to describe all common dynamic effects usually implemented in fixed-function entities
        including skinning, morphing, augmented reality functionality, etc.
        The basic principle of Xflow is a small addition to the general data model: It allows attaching an operator to a
        <a href="#data-elements">data element</a>
        using the <code>compute</code> attribute. A data element with such a <a href="#h-the-compute-operator">compute
          operator</a>
        attached first composes the data table as usual. This data tabe is then used as the input of the compute operator. The output of
        the compute operator (i.e. the result) is merged with original data table.
        In this merge, entries from the result table override entries with the same name from the input table.
      </p>


        <section>
            <h4>The compute operator</h4>

            <p>Compute operators can be used to change or create data inside an Xflow graph. They operate like
                functions, receiving a set of input arguments, doing some work
                and then outputting the result. On a <a>data element</a> an operator may be invoked through the <code>compute</code>
                attribute using the following syntax:</p>

        <pre>
         compute="(output1 [,output2...]) = xflow.[operatorName]([argument1, ...])"
        </pre>

            <p>In a <a>dataflow element</a> one or more compute operators can be invoked inside a compute block using
                the
                <a href="#the-dataflow-element" class="internalDFN">compute element</a>.</p>

            <p>The fields listed as outputs will be added to the list of data that this data element provides. The
                arguments must be available to the data element that invokes
                the operator, either as <a href="#value-elements">value elements</a> or provided by a child data
                element. Compute operators can be invoked in sequence by nesting data
                elements: </p>

        <pre class='example highlight'>
          &lt;data compute="position = xflow.add(position, offset2)"&gt;
            &lt;data compute="position = xflow.add(position, offset1)"&gt;
              &lt;float3 name="position"&gt;...&lt;/float3&gt;
              &lt;float3 name="offset1"&gt;...&lt;/float3&gt;
            &lt;/data&gt;
            &lt;float3 name="offset2"&gt;...&lt;/float3&gt;
          &lt;/data&gt;
        </pre>

            <p>XML3D includes several compute operators by default (a complete list may be found <a
                    href="https://github.com/xml3d/xml3d.js/wiki/Xflow-operator-list">here</a>)
                but also provides an interface to declare custom compute operators. These can be saved in their own
                JavaScript files and served alongside xml3d.js. Before being used a custom
                operator must be registered with Xflow by calling <code>Xflow.registerOperator</code> with the following
                syntax:</p>

        <pre class="example highlight">
          Xflow.registerOperator("xflow.myOperatorName", {
            outputs: [ {type: 'float3', name: 'outputName', customAlloc=true },
                       ...
            ],

            params:  [ {type: 'int', source: 'inputName1', optional=true },
                       {type: 'float3', source: 'inputName2', array=true },
                       ...
            ],

            alloc: function(sizes [, inputName1, ...]) {
               // Only necessary if one or more outputs have the flag 'customAlloc=true'
               sizes['outputName'] = inputName2.length;
            },

            evaluate: function(outputName, inputName1, inputName2, info) {
               ...
            }
          });
        </pre>
            <div class="note">As long as a custom operator appears after the <code>xml3d.js</code> script in the
                document flow the <code>Xflow.registerOperator</code> function can (and should)
                be called immediately. This is typical behavior for a JavaScript plugin architecture and ensures the
                operators have been registered before XML3D initializes the scene (during the
                <code>document.onload</code> event).
            </div>

            <p>In essence the declaration of the compute operator must contain at least a list of input and output
                fields, including types, and an <code>evaluate</code> function that is called by
                Xflow during data processing. Input fields may be marked as <code>optional</code>, otherwise they will
                generate an error if missing.

            </p>

            <p>Output fields may be allocated
                with a custom size, indicated with the <code>customAlloc</code> flag. When this flag is present Xflow
                will call the <code>alloc</code> function, which should declare the sizes of the
                data arrays that Xflow needs to create for these fields. If a field is not marked with
                <code>customAlloc</code> then Xflow will attempt to choose the right size based on the inputs to the
                compute operator.
            </p>

            <p>
                Fields marked with the <code>array</code> flag will be provided to the <code>evaluate</code> function as
                is and will exclude them from the normal length-matching checks that Xflow performs
                on input arguments. This can be used, for example, to pass an array of data with 100 elements while the
                other input fields all contain thousands of elements. Normally this would generate
                an error as Xflow would not be able to properly iterate through the data.</p>

            <p>The <code>evaluate</code> function will always be called with the list of output fields first, then the
                input fields, then an <code>info</code> object supplied by Xflow. The <code>info</code>
                object contains information about how the data can be iterated and offers a place to store data during
                processing:
            </p>

        <pre>
          info = {
            iterFlag: [true|false,...], // Is the input at this position an array that should be iterated over or a single element?
            iterateCount: number,       // The number of elements in the input data to iterate over, ie. (input array length) / (tuple size)
            customData: {}              // A field to hold custom data during and between operator executions
          }
        </pre>
            <div class="note">Fields marked with the <code>array</code> flag will always have an iterFlag value of
                <code>false</code></div>

            <p>The following is an example operator that uses the <code>info</code> object to iterate over a set of <em>positions</em>,
                adding a constant <em>offset</em> and returning the
                result as a new array of <em>positions</em>: </p>

        <pre class="example highlight">
          Xflow.registerOperator("xflow.addOffset", {
            outputs: [ {type: 'float3', name: 'result' }
            ],

            params:  [ {type: 'float3', source: 'position' },
                       {type: 'float3', source: 'offset', array=true }
            ],

            evaluate: function(result, position, offset, info) {
               // In this example 'offset' is an array with 3 values (a single float3)
               // 'position' is an array containing thousands of values

               for (var i=0; i < info.iterateCount; i++) {
                  result[i*3] = position[ info.iterFlag[0] ? i*3 : 0 ] + offset[0];
                  result[i*3+1] = position[ info.iterFlag[0] ? i*3+1 : 1 ] + offset[1];
                  result[i*3+1] = position[ info.iterFlag[0] ? i*3+2 : 2 ] + offset[2];
               }
            }
          }
        </pre>


        </section>

    </section>
</section>

<section>
    <h2>Style</h2>
    Since XML3D extends HTML, all [[CSS2]] properties also apply to XML3D elements. However, only the semantic of a few
    of them make sense for the 3D scene description.
    In the following we list the <dfn>relevant style properties</dfn> that influence the rendering of the scene.

    <div class="note">Other properties may affect XML3D elements in the future. Good candidates include the <code>visible</code>
        and <code>pointer-events</code> properties.
    </div>
    <section>
        <h3>The <code>display</code> property</h3>

        <div class="propdef">
            <dl>
                <dt>
                    <span class="index-def" title="'display'"><strong>'display'</strong></span>
                </dt>
                <dd>
                    <table class="propinfo" cellspacing="0" cellpadding="0">
                        <tbody>
                        <tr valign="baseline">
                            <td><em>Value:</em>&nbsp;&nbsp;</td>
                            <td>inline | block | list-item | inline-block |
                                table | inline-table | table-row-group | table-header-group |
                                table-footer-group | table-row | table-column-group | table-column |
                                table-cell | table-caption | none | inherit
                            </td>
                        </tr>
                        <tr valign="baseline">
                            <td><em>Initial:</em>&nbsp;&nbsp;</td>
                            <td>inherit
                            </td>
                        </tr>
                        <tr valign="baseline">
                            <td><em>Applies to:</em>&nbsp;&nbsp;</td>
                            <td><a href="#scene-elements">Scene elements</a>
                            </td>
                        </tr>
                        </tbody>
                    </table>
                </dd>
            </dl>
        </div>
        <p>The meanings of the values of this property for XML3D elements:</p>
        <dl>
            <dt><span class="index-def" title="'nonde', definition of"><strong>none</strong></span>
            </dt>
            <dd>This value causes an element to not contribute to the rendering, i.e. geometry elements are not
                rendered, light elements do not emit light
                into the scene. Also, geometry elements do not generate bounding boxes (empty boxes) nor contribute to
                their parent's bounding box.
                Descendant elements do not display and do not contribute to the parents' bounding boxes either.
            </dd>
            <dt><span class="index-def" title="definition of other values">&lt;other values&gt;</span>
            </dt>
            <dd>All other values do not affect the rendering of the element.
            </dd>
        </dl>

        A 'display' value of <code>none</code> will hide all descendant elements regardless of their local properties,
        as it does in HTML.

        Here are some examples for the 'display' property:
    <pre class="example highlight">
      mesh.hidden { display: none } /* do not display meshes with hidden class */
      xml3d > * > * > * > * model { display: none; } /* Hide all models deeper than the fifth hierarchy level */
    </pre>

        Modifying the <code>display</code> property with jQuery:
    <pre class="example highlight">
      $("#myMesh").hide();
      $(".walls").toggle();
    </pre>

        <div class="note">
            Be careful when assigning <code>display: none</code> to the xml3d element itself (or a parent of it). In HTML,
            elements with <code>display: none</code> have a width and height of 0 and this may cause XML3D to be initialized improperly.
        </div>


    </section>

    <section>
        <h3>The <code>transform</code> property</h3>

        <div class="propdef">
            <dl>
                <dt>
                    <span class="index-def" title="'transform'"><strong>'transform'</strong></span>
                </dt>
                <dd>
                    <table class="propinfo" cellspacing="0" cellpadding="0">
                        <tbody>
                        <tr valign="baseline">
                            <td><em>Values:</em>&nbsp;&nbsp;</td>
                            <td>translateX | translateY | translateZ | translate3d | rotateX | rotateY | rotateZ |
                                rotate3d
                                | scaleX | scaleY | scaleZ | scale3d | matrix3d
                            </td>
                        </tr>
                        <tr valign="baseline">
                            <td><em>Initial:</em>&nbsp;&nbsp;</td>
                            <td>identity matrix
                            </td>
                        </tr>
                        <tr valign="baseline">
                            <td><em>Applies to:</em>&nbsp;&nbsp;</td>
                            <td><a href="#transformable-elements">Transformable elements</a>
                            </td>
                        </tr>
                        </tbody>
                    </table>
                </dd>
            </dl>
        </div>

        <p>[[CSS3-transforms]] can be used to specify 3D transformations for any transformable element. The transform
            property may hold any number and combination of
            values, which will be combined from left to right. Transformations also apply to all descendant scene
            elements, building a transformation hierarchy. </p>

        <div class="note">Some transform functions (eg. <code>translate3d</code>) require a unit of measurement to be
            valid. Because browsers do not yet support units that make sense
            for a 3D scene these values should be given in 'px'. For example, <code>translate3d(10px, 5px, 0px)</code>.
            Internally these transformations will of course be in the units that
            the scene uses.
        </div>

        <div class="note">Some browsers silently ignore invalid CSS transforms. If a CSS transform is not behaving as
            expected double check to ensure the formatting and syntax are
            valid.
        </div>

    </section>

    <section>
        <h3>The <code>z-index</code> property</h3>

        <div class="propdef">
            <dl>
                <dt>
                    <span class="index-def" title="'z-index'"><strong>'z-index'</strong></span>
                </dt>
                <dd>
                    <table class="propinfo" cellspacing="0" cellpadding="0">
                        <tbody>
                        <tr valign="baseline">
                            <td><em>Value:</em>&nbsp;&nbsp;</td>
                            <td>auto | &lt;integer&gt;
                            </td>
                        </tr>
                        <tr valign="baseline">
                            <td><em>Initial:</em>&nbsp;&nbsp;</td>
                            <td>auto
                            </td>
                        </tr>
                        <tr valign="baseline">
                            <td><em>Applies to:</em>&nbsp;&nbsp;</td>
                            <td><a href="#scene-elements">Scene elements</a>
                            </td>
                        </tr>
                        </tbody>
                    </table>
                </dd>
            </dl>
        </div>
        <p>The meanings of the values of this property for XML3D elements:</p>
        <dl>
            <dt><span class="index-def" title="'none', definition of"><strong>auto</strong></span>
            </dt>
            <dd>This is the default value and causes the element to be rendered in the same z-layer (stacking context) as its parent element.
                If no other z-index values appear in the scene this means all elements will be rendered in a single z-layer according
                to their distance from the camera.
            </dd>
            <dt><span class="index-def" title="definition of other values">&lt;other values&gt;</span>
            </dt>
            <dd>Any value other than '0' will create a new stacking context, similar to the behavior of z-index for normal
                HTML elements.
            </dd>
        </dl>

        <p>During rendering objects will first be sorted into bins according to the stacking contexts present in the scene.
        Then the bins will be rendered from lowest z-index to highest, with the objects in each bin sorted according
        to their distance from the camera. The depth buffer will be cleared between each bin.</p>

        <p>This has the effect of rendering objects with a higher z-index on top of those with a lower z-index
        regardless of their spatial orientation in the scene.</p>

        <p>Note that the same stacking context rules apply for XML3D elements as for HTML elements. This means an
        element's z-index is always relative to the closest parent element having a z-index value other than 'auto'.</p>

        Here are some examples for the 'z-index' property:
    <pre class="example highlight">
        &lt;mesh src="example.xml" style="z-index: 5"&gt;&lt;/mesh&gt;
        &lt;mesh src="example.xml" style="z-index: 10"&gt;&lt;/mesh&gt; &lt;!-- Will always be drawn above the other two meshes --&gt;
        &lt;mesh src="example.xml" style="z-index: -5"&gt;&lt;/mesh&gt; &lt;!-- Will always be drawn below the other two meshes --&gt;
    </pre>

        In the example below the mesh with the z-index value of 500 will be drawn <em>below</em> the other meshes. This 
        is because both groups create their own stacking contexts, and the second group's z-index is lower than that of the first.
        <pre class="example highlight">
            &lt;group style="z-index: 1"&gt;
                &lt;mesh src="example.xml" style="z-index: 10"&gt;&lt;/mesh&gt; &lt;!-- Will always be drawn above the second mesh --&gt;
                &lt;mesh src="example.xml"&gt;&lt;/mesh&gt;
            &lt;/group&gt;
            &lt;group style="z-index: -1"&gt;
                &lt;mesh src="example.xml" style="z-index: 500"&gt;&lt;/mesh&gt; &lt;!-- Will be drawn *below* the other meshes --&gt;
            &lt;/group&gt;
        </pre>

    </section>

</section>

<section>
    <h2>The elements of XML3D</h2>
    <section>
        <h3>Kinds of elements</h3>
        <section>
            <h4>Transformable elements</h4>
            <dl class='element'>
                <a href="#the-assetmesh-element"><code>assetmesh</code></a>,
                <a href="#the-group-element"><code>group</code></a>, <a href="#the-mesh-element"><code>mesh</code></a>,
                <a href="#the-model-element"><code>model</code></a>, <a href="#the-light-element"><code>light</code></a>,
                <a href="#the-view-element"><code>view</code></a>
            </dl>
            <p>Transformable elements are those that are able to be transformed, either through CSS3 transforms or the
                <a>transform element</a>.
                Not all transformable elements can be nested but when they are they build a transformation hierarchy,
                with the transformation matrix of each node being defined as its own
                local transformation matrix multiplied with the transformation matrix of its parent element. </p>

            <p>A third possibility for defining a transformation is to reference a <a>data element</a> through the
                <code>transform</code> attribute instead of a
                <a>transform element</a>. This <a>data element</a> may either contain a single
                <a href="#the-float-float2-float3-float4-and-float4x4-elements" class="internalDFN">float4x4</a> element
                with name <code>transform</code> or use a
                <a href="#the-compute-operator" class="internalDFN">compute operator</a> to generate the transformation
                matrix.
            </p>

            <div class="note">In cases where both a CSS transform and a <code>transform</code> attribute are given the
                CSS transform will take precedence.
            </div>

            <p>The following example shows four different ways of defining the same transformation on a <a>group
                element</a>.</p>

          <pre class="example highlight">
            &lt;!-- Using a CSS3 transform --&gt;
            &lt;group style="transform: translate3d(0px, 0px, 10px)"&gt;&lt;/group&gt;

            &lt;!-- Using a transform element --&gt;
            &lt;transform id="myTransformElement" translation="0 0 10"&gt;&lt;/transform&gt;
            &lt;group transform="#myTransformElement"&gt;&lt;/group&gt;

            &lt;!-- Giving the transformation matrix directly --&gt;
            &lt;data id="myDataTransform"&gt;
              &lt;float4x4 name="transform"&gt;1 0 0 0 0 1 0 0 0 0 1 10 0 0 0 1&lt;/float4x4&gt;
            &lt;/data&gt;
            &lt;group transform="#myDataTransform"&gt;&lt;/group&gt;

            &lt;!-- Computing the transformation matrix with an Xflow operator --&gt;
            &lt;data id="myComputeTransform" compute="transform = xflow.createTransform(translation)"&gt;
              &lt;float3 name="translation"&gt;0 0 10&lt;/float3&gt;
            &lt;/data&gt;
            &lt;group transform="#myComputeTransform"&gt;&lt;/group&gt;
          </pre>

        </section>
        <section>
            <h4>Data elements</h4>
            <dl class='element'>
                <a href="#the-assetdata-element"><code>assetdata</code></a>,
                <a href="#the-data-element"><code>data</code></a>, <a href="#the-dataflow-element"><code>dataflow</code></a>,
                <a href="#the-mesh-element"><code>mesh</code></a>, <a href="#the-material-element"><code>material</code></a>,
                <a href="#the-model-element"><code>model</code></a>, <a href="#the-light-element"><code>light</code></a>
            </dl>
            <p>Data elements are the non-leaf nodes of an Xflow graph. They may contain any combination of data elements
                and <a href="#value-elements">value elements</a>. They may also reference
                other data elements through the <code>src</code> attribute using a standard HTML URI.</p>

            <p>The ultimate function of a graph of data elements is to provide data to a "sink". Some data sinks in
                XML3D include the <a>mesh element</a>, the
                <a>material element</a> and the <a href="#the-view-element"><code>projection</code></a> attribute of the
                <a>view element</a>. </p>

            <p>The ability to reference data elements makes it possible to share a common set of data between many
                different sinks. This saves memory and increases performance, as the data is also
                shared internally whenever possible. For example, a set of vertex positions may be shared between many
                instances of the same mesh using a different set of face indices each time. Internally
                these meshes will also share a common WebGL vertex position buffer:</p>
          <pre class="example highlight">
              &lt;data id="shared_positions"&gt;
                &lt;float3 name="position"&gt; 1.0 0.0 0.0 0.5 1.0 1.0 ... &lt;/float3&gt;
              &lt;/data&gt;
              &lt;mesh&gt;
                &lt;data src="#shared_positions"&gt;&lt;/data&gt;
                &lt;int name="index"&gt; 0 1 2 3 4 5 ... &lt;/int&gt;
              &lt;/mesh&gt;
              &lt;mesh&gt;
                &lt;data src="#shared_positions"&gt;&lt;/data&gt;
                &lt;int name="index"&gt; 3 4 5 0 1 2 ... &lt;/int&gt;
              &lt;/mesh&gt;
          </pre>

            <p>If two data elements containing fields with identical names are present in an XFlow data graph then the
                outermost value will replace any value
                nested deeper within the graph. In this example the value of the <code>color</code> field will be <code>1.0
                    0.0 0.0</code> when referencing <code>#my-data</code>:</p>

          <pre class='example highlight'>
              &lt;data id="my-data"&gt;
                  &lt;float3 name="color"&gt;1.0 0.0 0.0&lt;/float3&gt; &lt;!-- Overrides the nested color --&gt;
                  &lt;data&gt;
                      &lt;float3 name="color"&gt;1.0 1.0 1.0&lt;/float3&gt;
                  &lt;/data&gt;
              &lt;/data&gt;
         </pre>

        </section>
        <section>
            <h4>Value elements</h4>
            <dl class='element'>
                <a href="#the-float-float2-float3-float4-and-float4x4-elements"><code>float, float2, float3, float4,
                    float4x4</code></a>,
                <a href="#the-int-and-int4-elements"><code>int, int4</code></a>,
                <a href="#the-bool-element"><code>bool</code></a>,
                <a href="#the-texture-element"><code>texture</code></a>
            </dl>
            <p>Value elements are the leaf nodes of an Xflow graph. They may not be nested and may not contain any
                non-text child elements. Data should be provided as a text node
                containing a space-separated list of values. The tag name determines how this data is interpreted:</p>
          <pre class="example highlight">
              &lt;bool&gt;1 0 0&lt;/bool&gt;     // an array of three boolean values
              &lt;float3&gt;1 0 0&lt;/float3&gt; // a single three-dimensional floating point vector
          </pre>

            <p>The <code>name</code> attribute of a value element acts as an ID for the data contained in this element.
                It may be referenced in XFlow operators or
                in material shaders.</p>

            <p>If two value elements with the same name are present inside a <a>data element</a> then the value
                appearing later in the DOM will be used. In this example the
                value of the <code>color</code> field will be <code>1.0 1.0 1.0</code> when referencing
                <code>#my-data</code>:</p>

          <pre class='example highlight'>
                &lt;data id="my-data"&gt;
                    &lt;float3 name="color"&gt;1.0 0.0 0.0&lt;/float3&gt;
                    &lt;float3 name="color"&gt;1.0 1.0 1.0&lt;/float3&gt; &lt;!-- Overrides the previous color --&gt;
                &lt;/data&gt;
          </pre>

        </section>
        <section>
            <h4>Pickable elements</h4>
            <dl class='element'>
                <a href="#the-mesh-element"><code>mesh</code></a>,
                <a href="#the-model-element"><code>model</code></a></a>
            </dl>
            <p>Pickable elements are the drawable geometries of a scene. These elements can trigger mouse events like
                most visible HTML elements do, we call this
                <em>picking</em>. The list of available mouse event listeners is described in the <a href="#events">Events</a>
                section.</p>

            <p>Mouse events will also bubble up through the scene hierarchy, which allows mouse event listeners to also
                be placed on the <a>group element</a> and the
                <a>xml3d element</a>. Listeners on these elements can only be triggered by a pickable element (model or
                mesh) in the element's subtree.</p>

            <p>When the user interacts with an object on the canvas (eg. clicks on it) the relevant MouseEvent will be
                generated on the <a>mesh element</a>
                or <a>model element</a> and then bubbled up the scene hierarchy. This will continue until the event
                reaches the
                <a>xml3d element</a>, or until <code>event.stopPropagation()</code> is called.</p>

            <p>In the following example, when clicking on the object in the scene corresponding to this <a>mesh
                element</a>
                both listeners will be triggered in the appropriate order:</p>

           <pre class='example highlight'>
            &lt;group onmousedown="myMouseDownListener(event)"&gt;
                &lt;group&gt;
                    &lt;mesh onmouseup="myMouseUpListener(event)" type="triangles"&gt;&lt;/mesh&gt;
                &lt;/group&gt;
            &lt;/group&gt;
           </pre>

            <div class="note">Object visibility may affect whether or not mouse event listeners are triggered. See the
                <a href="#style">Style</a>
                section on visibility for more information.
            </div>

        </section>
    </section>

    <section>
        <h3>The root element</h3>
        <section>

<!-- #xml3d -->

            <h4>The <code>xml3d</code> element</h4>
            <dl class='element'>

            </dl>
            <p>The <dfn>xml3d element</dfn> is the root element of an XML3D scene. It will create a <code>canvas</code>
                element at this position in the DOM to
                display the rendered scene. CSS styles and event listeners from the XML3D element are also applied to
                the canvas allowing for mouse interaction with the
                XML3D scene. </p>

            <p>A page may have more than one XML3D element, in this case multiple canvases with their own WebGL contexts
                will be created. It is also possible to share date elements
                between scenes in which case XML3D will automatically create the necessary WebGL buffers for each
                context.</p>

            <p>Because XML3D uses HTML ids to reference elements it is important to avoid duplicate ids. For example, a
                duplicate id for a <code>data</code> element that appears
                in two different XML3D scenes on the same page may lead to undefined behavior. </p>

            <p>The <dfn id="attr-xml3d-view"><code>view</code></dfn> attribute, if present, must contain a selector that
                returns a <a>view element</a> as first matching element using <code>querySelector</code> on the xml3d
                element.
                The selection mechanism is described in the Selectors API [[selectors-api2]]. If the attribute is not
                present, or if the selector does not return a valid view element, the selector <code>view</code> is used
                instead,
                returning the first view in the scene. If no view is available, the system must append a view element as
                first child of the xml3d element.
            </p>

            <p>The background color of the 3D canvas may be set through CSS using the <code>background-color</code>
                property on the xml3d element.</p>

            <dl title='interface XML3DXml3dElement : HTMLElement' class='idl'>
                <dt>attribute unsigned long width</dt>
                <dd>Horizontal dimension</dd>
                <dt>attribute unsigned long height</dt>
                <dd>Vertical dimension</dd>
                <dt>readonly attribute boolean complete</dt>
                <dd>Returns true if all resources of the root element have been completely downloaded and rendered;
                    otherwise,
                    returns false.
                </dd>

                <dt>attribute DOMString view</dt>
                <dd>The view IDL attribute must reflect the respective content attribute of the same name.</dd>

                <dt>attribute Function onframedrawn</dt>
                <dd>Event listener to be executed whenever a new frame has been drawn. Is passed a <a>FrameDrawn</a>
                    event.
                </dd>
                <dt>attribute Function onload</dt>
                <dd>
                    Event listener to be executed when the <code>xml3d</code> element has finished loading. This event
                    is fired once after initial loading of the scene is complete, including
                    all external resources such as textures or external models. It will <b>not</b> be fired again if
                    subsequent changes to the scene cause more resources to be loaded. When adding
                    a listener for this event through JavaScript it may be necessary to check the status of the <code>complete</code>
                    attribute beforehand, as the <code>load</code> event will not
                    be resent if it was already dispatched before the listener was registered.
                    <div class="note">This event may be preceeded by one or more <a>FrameDrawn</a> events as XML3D
                        continues to redraw the scene even
                        as external resources are being loaded.
                    </div>
                </dd>


                <dt>HTMLElement? getElementByPoint()</dt>
                <dd>
                    Returns the element at the point with <b>window</b> coordinates x,y if there is a scene element;
                    otherwise, returns
                    null.
                    <dl class='parameters'>
                        <dt>unsigned long x</dt>
                        <dd>The x coordinate relative to the top left of the browser window</dd>
                        <dt>unsigned long y</dt>
                        <dd>The y coordinate relative to the top left of the browser window</dd>
                        <dt>optional Vec3 hitPoint</dt>
                        <dd>If provided this vector will be filled with the position of the hit point in world space.
                        </dd>
                        <dt>optional Vec3 hitNormal</dt>
                        <dd>If provided this vector will be filled with the normal of the hit point in world space.</dd>
                    </dl>
                </dd>

                <dt>HTMLElement? getElementByRay()</dt>
                <dd>Returns the first element that intersects with the ray if the ray intersects with a scene element;
                    otherwise,
                    returns null. Unlike <code>getElementByPoint</code> this function is not dependent on the currently
                    active view. This makes it useful for, for example,
                    finding the surface normal of an object at a particular point regardless of whether or not that
                    object is currently visible to the active camera.
                    <dl class='parameters'>
                        <dt>Ray ray</dt>
                        <dd></dd>
                        <dt>optional Vec3 hitPoint</dt>
                        <dd>If provided this vector will be filled with the position of the hit point in world space.
                        </dd>
                        <dt>optional Vec3 hitNormal</dt>
                        <dd>If provided this vector will be filled with the normal of the hit point in world space.</dd>
                    </dl>
                </dd>


                <dt>Box getLocalBoundingBox()</dt>
                <dd>Returns the bounding box of the scene. Because the XML3D element is the root element the bounding
                    box will be in world space by definition.
                </dd>

                <dt>Box getWorldBoundingBox()</dt>
                <dd>Returns the bounding box of the scene in world space.</dd>

                <dt>Ray generateRay()</dt>
                <dd>
                    Uses <a href="https://github.com/fintler/webgl-unproject">WebGL unProject</a> to generate a new ray
                    from the given x,y <b>window</b> coordinates.
                    <dl class='parameters'>
                        <dt>unsigned long x</dt>
                        <dd>The x coordinate relative to the top left of the browser window</dd>
                        <dt>unsigned long y</dt>
                        <dd>The y coordinate relative to the top left of the browser window</dd>
                    </dl>
                </dd>
            </dl>
        </section>
    </section>

    <section>
        <h3>Scene elements</h3>
        <section>

<!-- #group -->

            <h4>The <code>group</code> element</h4>
            <dl class='element'>
                <dt>Categories:</dt>
                <dd><a href="#transformable-elements">Transformable element</a></dd>
            </dl>
            <p>The <dfn>group element</dfn> is a non-leaf node in an XML3D scene tree. They can be used to build
                transformation hierarchies and to group
                renderable objects together. Groups can be nested, but because they are not Xflow elements they may not
                hold any
                <a href="#data-elements">data elements</a> and cannot be referenced by other <code>group</code>
                elements. This means that
                unlike data elements, groups build a tree structure rather than a graph. Each group may only have a
                single parent.</p>

            <p>Group elements inherit properties such as transformations, visibility and materials from their parent
                group. </p>

        <pre class="example highlight">
            &lt;group style="display: none;" material="#blueMaterial"&gt;
                &lt;group style="display: block;"&gt;
                    &lt;!-- This mesh will not be visible but will inherit #blueMaterial --&gt;
                    &lt;mesh type="triangles"&gt;&lt;/mesh&gt;
                &lt;/group&gt;
            &lt;/group&gt;
        </pre>
            <dl title='interface XML3DGroupElement : HTMLElement' class='idl'>
                <dt>attribute DOMString transform</dt>
                <dd>Accepts a URI fragment referencing a <a>transform element</a>. Alternatively a transformation may be
                    defined
                    with CSS through the style attribute.
                </dd>
                <dt>attribute DOMString material</dt>
                <dd>Accepts a URI fragment referencing a <a>material element</a>. Material is inherited from the parent
                    group if
                    this attribute is not present.
                </dd>
                <dt>Mat4 getWorldMatrix()</dt>
                <dd>Returns the transformation matrix of this group element in world space (includes parent
                    transformations).
                </dd>
                <dt>Mat4 getLocalMatrix()</dt>
                <dd>Returns the local transformation matrix of this group element (does not include parent
                    transformations).
                </dd>
                <dt>Box getLocalBoundingBox()</dt>
                <dd>Returns the bounding box of this group in its local transformation space. This is calculated as the
                    smallest volume containing the
                    bounding boxes of all child elements.
                </dd>

                <dt>Box getWorldBoundingBox()</dt>
                <dd>Returns the bounding box of this group in world space. This is calculated as the smallest volume
                    containing the
                    bounding boxes of all child elements.
                </dd>
            </dl>
        </section>
        <section>

<!-- #view -->

            <h4>The <code>view</code> element</h4>
            <dl class='element'>
                <dt>Categories:</dt>
                <dd><a href="#data-elements">Data element</a></dd>
                <dd><a href="#transformable-elements">Transformable element</a></dd>
            </dl>
            <p>The <dfn>view element</dfn> defines a viewport into the scene.
                The view (or camera) model that defines the projection of the scene to the XML3D canvas is defined by
                the <a href="#attr-view-model" class="internalDFN">model</a> attribute. The view uses the <a
                        href="#h-generic-data-model">generic data model</a> to define
                the parameters of the referenced view model (aka intrinsic camera parameters).
                The coordinate system of the <span class="element-name">view</span> element defines the coordinate
                system for the view (aka extrinsic camera parameters).
            </p>

            <p>
                The view model used by the view is defined by the <dfn id="attr-view-model">view model attribute</dfn>.
                If the <code>model</code> attribute is present, it must contain a valid non-empty URN referencing one of
                the <a>predefined view models</a>.
                If the URN is empty or references an unknown view model, or if the <code>model</code> attribute is not
                present, the <a>perspective view model</a> is used.

            <div class="note">Currently, XML3D supports predefined view models only. However, similar to materials, we
                envisage programmable view models for future versions of XML3D.
            </div>

            <p>This example illustrates the use of a view based on the predefined perspective view model using its
                default parameters:</p>
       <pre class='example highlight'>
        &lt;view&gt;&lt;/view&gt;
       </pre>
            It defines a perspective frustum that conforms to the right-handed rules and points along the negative
            z-axis. In the following example, the default direction is
            altered using CSS Transformations. Additionally, the perspective frustum has a different vertical
            field-of-view:
       <pre class='example highlight'>
        &lt;view style=&quot;transform: rotate3d(0, 1, 0, 180deg);&quot;&gt;
          &lt;float name=&quot;fovVertical&quot;&gt;0.5&lt;/float&gt;
        &lt;/view&gt;
       </pre>

            <p>This example illustrates the use of a projective view model using a custom projection matrix:</p>
       <pre class='example highlight'>
        &lt;view model=&quot;urn:xml3d:view:projective&quot;&gt;
          &lt;float4x4 name=&quot;projectionMatrix&quot;&gt;1.4485281705856323 0 0 0 0 2.4142134189605713 0 0 0 0 -9.523809432983398 -1 0 0 -94.18809509277344 0&lt;/float4x4&gt;
        &lt;/view&gt;
       </pre>
            <div class="note">XML3D does not provide camera navigation through the scene by e.g. binding mouse events to
                changes to the active view element.
                Instead, this is left to the application (or some navigation library), because the navigation is part of
                the interaction with the scene and is typically very application-specific.
            </div>

            <dl title='interface XML3DViewElement : HTMLElement' class='idl'>
                <dt>attribute DOMString model</dt>
                <dd>The <code>model</code> IDL attribute must reflect the <a href="#attr-view-model"
                                                                             class="internalDFN">model</a> content
                    attribute.
                </dd>
                <dt>Mat4 getWorldMatrix()</dt>
                <dd>Returns the transformation matrix of this view element in world space.
                </dd>
                <dt>Mat4 getLocalMatrix()</dt>
                <dd>Returns the local transformation matrix of this view element (does not include parent
                    transformations).
                </dd>

                <dt>Mat4 getViewMatrix()</dt>
                <dd>Returns the view matrix of the camera (the matrix used to transform from world to view space).
                </dd>
                <dt>Mat4 getProjectionMatrix()</dt>
                <dd>Returns the projection matrix for the frustum defined by this view.
                </dd>
            </dl>

        </section>
        <section>

<!-- #light -->

            <h4>The <code>light</code> element</h4>
            <dl class='element'>
                <dt>Categories:</dt>
                <dd><a href="#data-elements">Data element</a></dd>
                <dd><a href="#transformable-elements">Transformable element</a></dd>
            </dl>
            <p>The <dfn>light element</dfn> defines a light source in the scene that emits light based on the light
                model defined by
                the <a href="#attr-light-model" class="internalDFN">model</a> attribute. The light uses the <a
                        href="#h-generic-data-model">generic data model</a> to define the
                parameters of the referenced light model. The coordinate system of the <span
                        class="element-name">light</span> element defines the base coordinate system
                for the light. However, the final position and direction of the light source can altered by specific
                parameters of the light model.
            </p>

            <p>A light affects all geometry elements within the same scene, i.e. with the same xml3d element as
                ancestor.</p>

            <p>
                The light model used by the light is defined by the <dfn id="attr-light-model">model</dfn> attribute.
                If the <code>model</code> attribute is present, it must contain a valid non-empty URN referencing one of
                the <a href="#predefined-light-models">predefined light models</a>.
                If the URN is empty or references an unknown light model, or if the <code>model</code> attribute is not
                present, the <a href="#predefined-light-models">directional light</a> model is used.

            <div class="note">Currently, XML3D supports predefined light models only. However, similar to materials, we
                envisage programmable light models for future versions of XML3D.
            </div>


            <p>This example illustrates the use of a single light source based on the predefined directional light model
                using its default parameters:</p>
       <pre class='example highlight'>
        &lt;light&gt;&lt;/light&gt;
       </pre>
            Since no direction for the light source is specified for the light source, the default direction <code>0 0
            -1</code> (along the negative z axis) is transformed by the global
            coordinate system of the light element.

            <p>This example illustrates the use of a single light source based on the predefined point light model:</p>
       <pre class='example highlight'>
        &lt;light model=&quot;urn:xml3d:light:point&quot;&gt;
          &lt;float3 name=&quot;intensity&quot;&gt;0.8 0.8 1&lt;/float3&gt;
        &lt;/light&gt;
       </pre>


            <dl title='interface XML3DLightElement : XML3DDataElement' class='idl'>
                <dt>attribute DOMString model</dt>
                <dd>The <code>model</code> IDL attribute must reflect the <a href="#attr-light-model"
                                                                             class="internalDFN">model</a> content
                    attribute.
                </dd>

                <dt>Mat4 getWorldMatrix()</dt>
                <dd>Returns the transformation matrix of this light element in world space.
                </dd>
                <dt>Mat4 getLocalMatrix()</dt>
                <dd>Returns the local transformation matrix of this light element (does not include parent
                    transformations).
                </dd>
            </dl>

        </section>
        <section>

<!-- #mesh -->

            <h4>The <code>mesh</code> element</h4>
            <dl class='element'>
                <dt>Categories:</dt>
                <dd><a href="#data-elements">Data element</a></dd>
                <dd><a href="#pickable-elements">Pickable element</a></dd>
                <dd><a href="#transformable-elements">Transformable element</a></dd>
            </dl>

            <p>The <dfn>mesh element</dfn> represents a single renderable object in the scene. To be drawn correctly a
                mesh must either inherit a
                <a href="#the-material-element" class="internalDFN">material</a> from a parent element or assign its own
                through the <code>material</code> attribute. The
                <dfn id="attr-mesh-type">type attribute</dfn> determines how the mesh data is interpreted to be drawn
                and must be one of the
                <a href="#predefined-primitive-types">predefined primitive types</a>.</p>

            <div class="note">A mesh can only be assigned a single material. Models that contain multiple materials will
                have to be broken down into separate meshes.
            </div>

            <p>The simplest way to define a mesh is to include its data directly in the <code>mesh</code> element:</p>

        <pre class='example highlight'>
            &lt;mesh type="triangles" material="#myMaterial"&gt;
                &lt;int name="index"&gt;0 1 2 ... &lt;/int&gt;
                &lt;float3 name="position"&gt;1.0 0.0 0.0 ... &lt;/float3&gt;
                &lt;float3 name="normal"&gt;0.0 1.0 0.0 ... &lt;/float3&gt;
            &lt;/mesh&gt;
        </pre>

            <p>However it's usually a good idea to reference this data instead, either in the same document or in an
                external document as shown below:</p>

        <pre class='example highlight'>
            &lt;!-- myDataElement is the id of a data element containing the mesh data --&gt;
            &lt;mesh src="myMesh.xml#myDataElement" type="triangles" material="#myMaterial"&gt;&lt;/mesh&gt;
        </pre>

            <p>Each entry in the mesh data is passed on to the material shader in the form of a vertex attribute. A mesh
                must <i>always</i> supply at least a
                <code>position</code> entry, any others are optional but may be required by a material in order to be
                rendered properly (eg. <code>normal</code> in
                conjunction with the predefined <code>phong</code> material). </p>

            <p>As with any <a href="#data-elements">data element</a>, a mesh may override certain entries or supply its
                own. This applies even to material entries:</p>

        <pre class='example highlight'>
            &lt;!-- This mesh will be rendered with a blue diffuseColor even though the material specifies a red one --&gt;
            &lt;mesh src="myMesh.xml#myDataElement" type="triangles" material="#myRedMaterial"&gt;
                &lt;float3 name="diffuseColor"&gt;0.0 0.0 1.0&lt;/float3&gt;
            &lt;/mesh&gt;
        </pre>

            <p>The mesh type can also be set using the generic attribute system, setting the mesh type to
                <code>derived</code></p>
        <pre class='example highlight'>
            &lt;!-- The mesh data will be interpreted as lines --&gt;
            &lt;mesh src="teapot.json" type="derived"&gt;
                &lt;string name="type"&gt;lines&lt;/string&gt;
            &lt;/mesh&gt;
        </pre>


            <p>Different ways of assigning transformations to meshes are described in the
                <a href="#transformable-elements">transformable elements</a> section.</p>

            <dl title='interface XML3DMeshElement : HTMLElement' class='idl'>
                <dt>readonly attribute boolean complete</dt>
                <dd>Returns true if all external resources required by this mesh have been loaded, false otherwise.</dd>

                <dt>attribute DOMString type</dt>
                <dd>The primitive type that this mesh uses. Supported values are <code>triangles</code>,
                    <code>tristrips</code>,
                    <code>points</code>, <code>lines</code>, <code>linestrips</code> and <code>derived</code>.
                </dd>

                <dt>attribute DOMString src</dt>
                <dd>URI reference to another data element containing the data for this mesh. Can be a reference to an
                    external document.
                </dd>

                <dt>attribute DOMString material</dt>
                <dd>URI reference to a <a>material element</a>.</dd>

                <dt>attribute DOMString transform</dt>
                <dd>URI reference to a <a>transform element</a>.</dd>

                <dt>XML3DDataResult getResult(Array filter)</dt>
                <dd>Returns a XML3DDataResult object containing the data for the fields requested by the given filter,
                    eg.
                    <code>["position", "index", "normal"]</code>. This is useful for accessing the mesh data directly
                    through JavaScript.
                </dd>

                <dt>Array getOutputNames()</dt>
                <dd>Returns the names of the data fields available to this mesh node.</dd>

                <dt>Mat4 getWorldMatrix()</dt>
                <dd>Returns the transformation matrix of this mesh element in world space (includes parent
                    transformations).
                </dd>
                <dt>Mat4 getLocalMatrix()</dt>
                <dd>Returns the local transformation matrix of this mesh element (does not include parent
                    transformations).
                </dd>
                <dt>Box getLocalBoundingBox()</dt>
                <dd>Returns the bounding box of this mesh in object space, without any transformations applied.</dd>

                <dt>Box getWorldBoundingBox()</dt>
                <dd>Returns the bounding box of this mesh in world space.</dd>
            </dl>
        </section>

        <section>
<!-- #model -->

            <h4>The <code>model</code> element</h4>
            <dl class='element'>
                <dt>Categories:</dt>
                <dd><a href="#data-elements">Data element</a></dd>
                <dd><a href="#pickable-elements">Pickable element</a></dd>
                <dd><a href="#transformable-elements">Transformable element</a></dd>
            </dl>
            <p>The <dfn>model element</dfn> is used to instantiate an <a href="#the-asset-element" class="internalDFN">asset</a>.
                This is useful for rendering complex objects
                with many individual meshes or materials. Not only is it easier to insert a single <code>model</code>
                element into the DOM, it's also much
                more efficient. </p>

            <p>When referencing an external file the URI <i>must</i> contain the id of the <a>asset element</a> to be
                instantiated:</p>

          <pre class='example highlight'>
            &lt;model src="myExternalAsset.xml#myAsset"&gt;&lt;/model&gt;
          </pre>

            <p>A model may override data inside the Asset by specifying the <a>assetmesh element</a> or <a>assetdata
                element</a> that should be overwritten.
                For example, to change the material of a mesh inside the Asset named "hat" we would define our model tag
                as follows:</p>

          <pre class='example highlight'>
            &lt;model src="myExternalAsset.xml#myAsset"&gt;
               &lt;assetmesh name="hat" material="#aNewMaterialDefinedLocally"&gt;&lt;/assetmesh&gt;
            &lt;/model&gt;
          </pre>

            <div class="note">Materials inside the asset will always override those assigned to the <code>model</code>.
                To assign a material from outside the
                asset either remove all inner materials entirely or override each <code>assetmesh</code> individually as
                shown above.
            </div>

            This behavior is especially useful in driving animations inside the instantiated asset. Each instance of the
            <code>model</code> element can have its
            own animation state, even if all reference the same asset. Typically this is done by exposing the animation
            key through its own <code>assetdata</code>, which
            is then overwritten in the <code>model</code>:

          <pre class='example highlight'>
            &lt;!-- Assuming "myAsset" contains an assetdata element with name "animation" --&gt;
            &lt;model src="myExternalAsset.xml#myAsset"&gt;
               &lt;assetdata name="animation"&gt;
                &lt;float id="animation_key" name="key"&gt;1.0&lt;/float&gt;
              &lt;/assetdata&gt;
            &lt;/model&gt;
          </pre>

            By changing the value of the <code>animation_key</code> through JavaScript we can now control the model's
            animation state.

            <dl title='interface XML3DModelElement : HTMLElement' class='idl'>
                <dt>attribute DOMString src</dt>
                <dd>URI reference to an <a>asset element</a> that this <code>model</code> should instantiate.</dd>

                <dt>attribute DOMString material</dt>
                <dd>URI reference to a <a>material element</a>. This material will only be used for
                    objects that do not define their own material inside the <code>asset</code>.
                </dd>

                <dt>attribute DOMString transform</dt>
                <dd>URI reference to a <a>transform element</a>.</dd>

                <dt>Mat4 getWorldMatrix()</dt>
                <dd>Returns the transformation matrix of this model in world space, including parent transformations.
                </dd>

                <dt>Mat4 getLocalMatrix()</dt>
                <dd>Returns the local transformation matrix of this model element (does not include parent
                    transformations).
                </dd>

                <dt>Box getLocalBoundingBox()</dt>
                <dd>Returns the bounding box of this model without any parent transformations applied.</dd>

                <dt>Box getWorldBoundingBox()</dt>
                <dd>Returns the bounding box of this model in world space, including parent transformations.</dd>
            </dl>

        </section>

    </section>

    <section>
        <h3>Definition Areas</h3>
        <section>

<!-- #defs -->

            <h4>The <code>defs</code> element</h4>
            <dl class='element'>
            </dl>
            <p>The <dfn>defs element</dfn> is simply an organizational tool to separate the scene tree from elements
                that are not explicitly
                part of the scene, but may be referenced by elements that are. These implicit elements include <a
                        href="#the-transform-element" class="internalDFN">transform</a>,
                <a href="#the-material-element" class="internalDFN">material</a>, <a href="#the-data-element"
                                                                                     class="internalDFN">data</a> and <a
                        href="#the-dataflow-element" class="internalDFN">dataflow</a>. Note that
                any of these elements may appear inside the scene tree as well, it's just good practice to keep them in
                the <code>defs</code> section
                whenever possible.</p>

            Ideally the only elements that should appear outside the <code>defs</code> section are <a
                href="#the-group-element" class="internalDFN">group</a>,
            <a href="#the-mesh-element" class="internalDFN">mesh</a>, <a href="#the-model-element" class="internalDFN">model</a>,
            <a href="#the-view-element" class="internalDFN">view</a> and
            <a href="#the-model-element" class="internalDFN">light</a>.
            Note that these elements will be ignored if they are inside the <code>defs</code> section, since it is not
            considered part of the scene tree.
            <a href="#data-elements">data elements</a> usually belong in the <code>defs</code> section but may also be
            part of the
            scene tree if contained by a <a>mesh element</a>.

        <pre class="example highlight">
          &lt;xml3d&gt;
            &lt;defs&gt;
               &lt;transform id="myTransform" rotation="0 1 0 0.75"&gt;
               &lt;data id="myMeshData" &gt;
                  &lt;float3 name="position"&gt;1.0 0.0 0.0 ...&lt;/float3&gt;
               &lt;/data&gt;
            &lt;/defs&gt;

            &lt;group transform="#myTransform"&gt;
               &lt;mesh src="#myMeshData" type="triangles"&gt;&lt;/mesh&gt;
            &lt;/group&gt;
          &lt;/xml3d&gt;
        </pre>
        </section>
    </section>

    <section>
        <h3>Property elements</h3>
        <section>

<!-- #material -->

            <h4>The <code>material</code> element</h4>
            <dl class='element'>
                <dt>Categories:</dt>
                <dd><a href="#data-elements">Data element</a></dd>
            </dl>
            <p>A material describes the surface shading of an object.
                Materials are defined using the <dfn>material element</dfn> and then
                referenced by the <a href="#dfn-material-property" class="internalDFN">material</a> property on a given
                <a href="#scene-elements">scene
                    element</a> to indicate that the
                given element shall be shaded using the referenced material. Multiple scene elements can share a
                material.
                The material uses the generic data model to define the parameters of the referenced material model.
                Note that graphics elements can override the parameters defined in the material element. Hence, the
                parameters in
                the material element can be considered default values.</p>


            <p>
                The material model used by the material is defined by the <dfn id="attr-material-model">material model
                attribute</dfn>.
                The <code>model</code> attribute must be present, and must contain a valid non-empty URL referencing
                either a <a href="#predefined-material-models">predefined material model</a> or
                a scripted material model, e.g. using shade.js or a custom shader.
            </p>

            <p>Here is a simple example for a material based on the predefined <a>phong material model</a>:</p>
       <pre class='example highlight'>
        &lt;material model=&quot;urn:xml3d:material:phong&quot;&gt;
          &lt;float3 name=&quot;diffuseColor&quot;&gt;0 0 1&lt;/float3&gt;
          &lt;texture name=&quot;diffuseTexture&quot;&gt;
            &lt;img src=&quot;../stone.jpg&quot;/&gt;
          &lt;/texture&gt;
        &lt;/material&gt;
       </pre>

            <dl title='interface XML3DMaterialElement : XML3DDataElement' class='idl'>
                <dt>attribute DOMString model</dt>
                <dd>The <code>model</code> IDL attribute must reflect the <a href="#attr-material-model"
                                                                             class="internalDFN">model</a> content
                    attribute.
                </dd>
            </dl>
        </section>
        <section>
            <h4>The <code>transform</code> element</h4>
            <dl class='element'>
            </dl>

            <p>In addition to CSS3 transformations applied through the <code>style</code> attribute, the <dfn>transform
                element</dfn> provides another way to define transformations for
                <a href="#transformable-elements">transformable elements</a>. The various transformation components are
                combined into a transformation matrix which is then applied to the
                element or elements referencing this transform element. </p>

            <p>Transform elements are generally placed into the <a href="#the-defs-element"><code>defs</code></a>
                section of a scene, however it's possible to define them anywhere inside the
                <a>xml3d element</a>. No matter where a transform element is defined it must be referenced by its <code>id</code>
                from the <code>transform</code> attribute
                of a <a href="#transformable-elements">transformable element</a> to be used. A single transform element
                can be referenced by multiple other elements. </p>

            <dl title='interface XML3DTransformElement : HTMLElement' class='idl'>
                <dt>attribute AxisAngle scaleorientation</dt>
                <dd>The orientation on which to apply the scaling factor supplied by the IDL attribute <i>scale</i>. In
                    axis-angle form [x,y,z,a] with the angle expressed in radians.
                </dd>
                <dt>attribute AxisAngle rotation</dt>
                <dd>The rotation component of this transformation. In axis-angle form [x,y,z,a] with the angle expressed
                    in radians.
                </dd>
                <dt>attribute Vec3 translation</dt>
                <dd>The translation component of this transformation.</dd>
                <dt>attribute Vec3 scale</dt>
                <dd>The scale component of this transformation. Note: non-uniform scaling and negative values are
                    allowed.
                </dd>
                <dt>attribute Vec3 center</dt>
                <dd>The center point of this transformation.</dd>
            </dl>
        </section>
    </section>

    <section>
        <h3>Assets</h3>

        <p>The XML3D asset format is designed to encompass everything needed to define a complex model consisting of one
            or more meshes and materials. Conceptually an asset is
            designed to be static and self-enclosed. When referenced from a <a>model element</a> an asset behaves as a
            single object in the scene,
            even though it may be composed of many different meshes. Interaction through mouse event listeners, for
            example, can only be done on the
            <a href="#the-model-element" class="internalDFN">model</a> level and not on the level of individual meshes
            comprising the asset. </p>

        <p>As with other Xflow elements most parts of the asset (eg. materials, mesh data, transformations) can be
            overridden inside the <a>model element</a>. However it's important
            to note that adding or removing overrides for assets has a very high performance penalty. Best practice is
            to define all the necessary overrides during construction of the
            <a>model element</a> and then stick to changing the <i>values</i> of those overrides, which carries no
            performance penalty. See the
            <a href="https://github.com/xml3d/xml3d.js/wiki/Using-Assets-and-Models#overriding-parts-of-an-asset">XML3D
                Wiki</a> for more information on how to override asset data.</p>

        <p>It's important to note that unlike a <a href="#the-group-element" class="internalDFN">group</a> and <a
                href="#the-mesh-element" class="internalDFN">mesh</a> hierarchy,
            assets are always flattened. An asset always consists of an <a>asset element</a> with a list of <a
                    href="#the-assetmesh-element" class="internalDFN">assetmesh elements</a>
            as children, which cannot be nested. <a href="#the-asset-element" class="internalDFN">Asset elements</a>
            themselves, on the other hand, can be nested.</p>

        <section>

<!-- #asset -->

            <h4>The <code>asset</code> element</h4>
            <dl class='element'>
            </dl>

            <p>The <dfn>asset element</dfn> defines an asset that can be instantiated through a <a>model element</a> or
                extended by another asset. The asset element also
                defines a scope for the <code>name</code> and <code>includes</code> attributes of any child <a
                        href="#the-assetdata-element" class="internalDFN">assetdata</a>
                and <a href="#the-assetmesh-element" class="internalDFN">assetmesh</a> elements. </p>

            <p>Asset elements may be nested but their <code>id</code> must be unique within the document. </p>

            <dl title='interface XML3DAssetElement : HTMLElement' class='idl'>
                <dt>attribute DOMString src</dt>
                <dd>A URI to another asset that this one should extend.</dd>
            </dl>
        </section>
        <section>

<!-- #assetdata -->

            <h4>The <code>assetdata</code> element</h4>
            <dl class='element'>
                <dt>Categories:</dt>
                <dd><a href="#data-elements">Data element</a></dd>
            </dl>

            <p>Similar to the <a>data element</a> an <dfn>assetdata element</dfn> is used to define and share generic
                data within an asset. Unlike <code>data</code>
                elements, assetdata elements may not be nested and are named by and referenced through a
                <code>name</code> attribute rather than an <code>id</code>. An assetdata element
                may contain normal <a href="#the-data-element" class="internalDFN">data elements</a> as children.</p>

            <p>Assetdata names must be unique within an <a>asset element</a>.</p>

            <dl title='interface XML3DAssetdataElement : HTMLElement' class='idl'>
                <dt>attribute DOMString name</dt>
                <dd>The name of this assetdata element. The name is scoped to the surrounding <a>asset element</a> and
                    may not be duplicated within this scope.
                </dd>
                <dt>attribute DOMString includes</dt>
                <dd>A space separated list of names corresponding to other <a href="#the-assetdata-element"
                                                                              class="internalDFN">assetdata elements</a>
                    that this one should extend.
                </dd>
            </dl>
        </section>
        <section>

<!-- #assetmesh -->

            <h4>The <code>assetmesh</code> element</h4>
            <dl class='element'>
                <dt>Categories:</dt>
                <dd><a href="#data-elements">Data element</a></dd>
                <dd><a href="#transformable-elements">Transformable element</a></dd>
            </dl>

            <p>An <dfn>assetmesh element</dfn> represents a single drawable mesh in the asset and works similar to the
                <a>mesh element</a>. Unlike the <a>mesh element</a>
                assetmeshes are identified by their <code>name</code> attribute, which may not be duplicated within the
                same <a>asset element</a>.</p>

            <p>As with the <a>mesh element</a> a transformation may be supplied either through the
                <code>transform</code> attribute or through a CSS3 transform.</p>

      <pre class="example highlight">
        &lt;assetmesh name="exampleMesh" style="transform: translate3d(0px, 0px, 10px)" type="triangles" material="#exampleMaterial"&gt;
          &lt;data src="#myMeshData"&gt;&lt;/data&gt;
          &lt;assetdata src="#someMoreMeshData"&gt;&lt;/assetdata&gt;
        &lt;/assetmesh&gt;
      </pre>

            <dl title='interface XML3DAssetmeshElement : HTMLElement' class='idl'>
                <dt>attribute DOMString name</dt>
                <dd>The name of this <code>assetmesh</code> element. The name is scoped to the surrounding <a>asset
                    element</a> and may not be duplicated within this scope.
                </dd>
                <dt>attribute DOMString includes</dt>
                <dd>A space separated list of names corresponding to other <code>assetmesh</code> or <a
                        href="#the-assetdata-element" class="internalDFN">assetdata</a>
                    elements that this one should extend.
                </dd>
                <dt>attribute DOMString type</dt>
                <dd>The primitive type of this <code>assetmesh</code>. Supported values are <code>triangles</code>,
                    <code>tristrips</code>, <code>points</code>, <code>lines</code>, <code>linestrips</code>, and <code>derived</code>
                </dd>
                <dt>attribute DOMString material</dt>
                <dd>URI reference to a <a>material element</a>.</dd>
                <dt>attribute DOMString transform</dt>
                <dd>URI reference to a <a>transform element</a>.</dd>
            </dl>

        </section>

    </section>

    <section>
        <h3>Data and dataflow elements</h3>
        <section>

<!-- #data -->

            <h4>The <code>data</code> element</h4>
            <dl class='element'>
                <dt>Categories:</dt>
                <dd><a href="#data-elements">Data element</a></dd>
            </dl>
            <p>A <dfn>data element</dfn> is a non-leaf node in an Xflow graph. They act primarily as containers for data
                but may also modify that data through
                compute operators and filters. When data elements are nested the data from all child elements is merged,
                in this sense the parent data element acts as a data
                aggregator. In the case of two data fields with the same name the data element further down the list in
                the DOM will have priority. For example:</p>

        <pre class='example highlight'>
        &lt;data&gt; &lt;!-- At this level "color" will be "0.0 1.0 0.0" --&gt;
          &lt;data&gt;
            &lt;float3 name="color"&gt;1.0 0.0 0.0&lt;/float3&gt;
          &lt;/data&gt;
          &lt;data&gt;
            &lt;float3 name="color"&gt;0.0 1.0 0.0&lt;/float3&gt;
          &lt;/data&gt;
        &lt;/data&gt;
        </pre>

            <p>Data elements may also reference other data elements. This can be used to share a common dataset between
                objects, overwriting certain fields on a
                per-object basis as required. See the <a href="#data-elements">data elements</a> section for an example.
            </p>

            <p>One important use for data elements is to dynamically change or generate data, for example to drive an
                animation or generate a ground mesh from a height map.
                This can be accomplished with a combination of compute operators and data overrides. The following is an
                example of a simple compute operator that will add the
                provided offset to all vertex positions of a mesh:</p>

         <pre class='example highlight'>
        &lt;mesh&gt;
           &lt;data compute="position = xflow.add(position, offset)"&gt;
             &lt;float3 name="offset"&gt;0.5 0.5 0.5 ... &lt;/float3&gt;
             &lt;data id="originalData"&gt;
                &lt;float3 name="position"&gt;1.0 0.0 0.0 ... &lt;/float3&gt;
             &lt;/data&gt;
           &lt;/data&gt;
        &lt;/mesh&gt;
        </pre>

            When using a compute operator with a data element all input arguments must be available to the data element
            that invokes the operator. In this example the
            "position" field of the <code>mesh</code> will contain the offset position data, while the data element with
            id <code>originalData</code> will contain the
            original positions. If this data element were referenced from another mesh it would also return the original
            positions:

        <pre class='example highlight'>
        &lt;mesh&gt;
            &lt;!-- "positions" contains the original data 1.0 0.0 0.0 ... --&gt;
           &lt;data src="#originalData"&gt;&lt;/data&gt;
        &lt;/mesh&gt;
        </pre>

            Xflow is designed as a reactive framework, meaning operators will only be recomputed if input data has
            changed and a sink element has requested the
            output data (eg. during a draw call in a subsequent frame).

            <dl title='interface XML3DDataElement : HTMLElement' class='idl'>
                <dt>readonly attribute boolean complete</dt>
                <dd>Returns true if all external resources required by this data have been loaded, false otherwise.</dd>
                <dt>attribute DOMString compute</dt>
                <dd>A Javascript-like statement that can invoke an Xflow compute operator on a set of input data. See
                    the <a href="#the-compute-operator">compute operator</a>
                    section for more information.
                </dd>
                <dt>attribute DOMString filter</dt>
                <dd>May contain a filter (<code>keep</code>, <code>rename</code> or <code>remove</code>) to adjust the
                    data that is provided by this data element. See the
                    Wiki page <a href="https://github.com/xml3d/xml3d.js/wiki/How-to-use-Xflow">How to use Xflow</a> for
                    more information.
                </dd>
                <dt>attribute DOMString src</dt>
                <dd>Accepts an HTML ID reference to another data element. The other element's data will be included as
                    an implicit first child of this data node. Note that in
                    cases of duplicate data any child data or value elements will override the data found in the <code>src</code>
                    node.
                </dd>
                <dt>XML3DDataResult getResult(Array filter)</dt>
                <dd>Returns a XML3DDataResult object containing the data for the fields requested by the given filter,
                    eg.
                    <code>["position", "index", "normal"]</code>. This is useful for accessing the data directly through
                    JavaScript.
                </dd>

                <dt>Array getOutputNames()</dt>
                <dd>Returns the names of the data fields provided by this data element.</dd>
            </dl>
        </section>

<!-- #dataflow -->

        <section>
            <h4>The <code>dataflow</code> element</h4>
            <dl class='element'>
                <dt>Categories:</dt>
                <dd><a href="#data-elements">Data element</a></dd>
            </dl>

            <p>The <dfn>dataflow element</dfn> can be thought of as a template for a compute operation consisting of one
                or more Xflow operators executed in sequence.
                This template can be defined once and then reused many times in the scene, applying the operations to a
                different set of input data each time.
                Consider the following dataflow example which computes <a
                        href="http://en.wikipedia.org/wiki/Skeletal_animation">skeletal animation</a>
                for a mesh:</p>

       <pre class='example highlight'>
        &lt;dataflow id="skinning" out="position, normal, boneXform"&gt;
          &lt;float3 param="true" name="position" &gt;&lt;/float3&gt;
          &lt;float3 param="true" name="normal" &gt;&lt;/float3&gt;
          &lt;int4   param="true" name="boneIdx" &gt;&lt;/int4&gt;
          &lt;float4 param="true" name="boneWeight" &gt;&lt;/float4&gt;

          &lt;int    param="true" name="boneParent" &gt;&lt;/int&gt;
          &lt;float3 param="true" name="bindTranslation" &gt;&lt;/float3&gt;
          &lt;float4 param="true" name="bindRotation" &gt;&lt;/float4&gt;

          &lt;float3 param="true" name="translation" &gt;&lt;/float3&gt;
          &lt;float4 param="true" name="rotation" &gt;&lt;/float4&gt;

          &lt;float  param="true" name="key" &gt;0&lt;/float&gt;
          &lt;compute&gt;
            bindPose = xflow.createTransformInv({translation: bindTranslation, rotation: bindRotation});
            bindPose = xflow.forwardKinematicsInv(boneParent, bindPose);

            rot = xflow.slerpSeq(rotation, key);
            trans = xflow.lerpSeq(translation, key);
            pose = xflow.createTransform({translation: trans, rotation: rot});
            pose = xflow.forwardKinematics(boneParent, pose);

            boneXform = xflow.mul(bindPose, pose);

            normal = xflow.skinDirection(normal, boneIdx, boneWeight, boneXform);
            position = xflow.skinPosition(position, boneIdx, boneWeight, boneXform);
          &lt;/compute&gt;
        &lt;/dataflow&gt;
        </pre>

            <p>By defining the <code>param</code> attribute of the various <a href="#value-elements">value elements</a>
                we instruct Xflow to expect them as inputs provided
                by any element that references this dataflow. The <code>compute</code> element is only found inside
                dataflows and can be used to define a sequence of Xflow operators
                that should be applied to the input data. The list of operators will be computed from top to bottom and
                any new data fields they create (ie. <code>bindPose</code> in
                this example) can be used as input for operators further down the list.
            </p>

            <p>To apply this dataflow to a set of data another <a href="#data-elements">data element</a> may reference
                it in its own <code>compute</code> block or attribute:</p>

      <pre class='example highlight'>
        &lt;data compute="position, normal = dataflow['#skinning']"&gt;
          &lt;!-- We assume this file contains all the input data that the 'skinning' dataflow expects --&gt;
          &lt;data src="myMeshData.xml"&gt;&lt;/data&gt;
          &lt;float id="myAnimationKey" name="key"&gt;1.0&lt;float&gt;
        &lt;/data&gt;
      </pre>

            <p>
                Conceptually this data element will 'call' the dataflow element with the input 'arguments' from the file
                <code>myMeshData.xml</code> and then assign the output
                of the dataflow to the <code>position</code> and <code>normal</code> fields, effectively overriding the
                ones found in <code>myMeshData.xml</code>.
                Note the URI fragment inside the <code>dataflow[]</code> construct. This may also reference an external
                document containing the dataflow.
            </p>

            <p>By declaring the <code>key</code> value separately we can control the animation state of this model. Note
                also that the key is declared <em>after</em> the reference
                to <code>myMeshData.xml</code> to ensure that it overrides the key value found in the xml file.</p>


            <dl title='interface XML3DDataflowElement : HTMLElement' class='idl'>
                <dt>attribute DOMString out</dt>
                <dd>A comma-separated list of fields that this dataflow provides as output. If this attribute is not
                    present then all computed fields will be provided as output.
                </dd>
                <dt>readonly attribute boolean complete</dt>
                <dd>Returns true if all external resources required by this dataflow have been loaded, false
                    otherwise.
                </dd>
                <dt>XML3DDataResult getResult(Array filter)</dt>
                <dd>Returns a XML3DDataResult object containing the data for the fields requested by the given filter,
                    eg.
                    <code>["position", "index", "normal"]</code>. This is useful for accessing the data directly through
                    JavaScript.
                </dd>
                <dt>Array getOutputNames()</dt>
                <dd>Returns the names of the data fields provided by this data element.</dd>
            </dl>
        </section>

        <section>
<!-- #float -->

            <h4>The <code>float</code>, <code>float2</code>, <code>float3</code>, <code>float4</code>, and
                <code>float4x4</code> elements</h4>
            <dl class='element'>
                <dt>Categories:</dt>
                <dd><a href="#value-elements">Value element</a></dd>
            </dl>
            <p>The <code>float*</code> elements hold a space separated list of floating point values. The tag name
                determines how this data is interpreted, ie. a <code>float2</code> element
                will interpret the data as an array of 2D vectors while a <code>float4x4</code> element will interpret
                it as an array of 4x4 matrices. </p>

            <dl title='interface XML3DFloatValueElement : HTMLElement' class='idl'>
                <dt>attribute DOMString name</dt>
                <dd>The name of the value element. A good name should be a semantic description of the data that this
                    element holds.
                </dd>
                <dt>attribute boolean param</dt>
                <dd>Marks this value as one to be supplied by a different data element. Value elements with the <code>param</code>
                    attribute are
                    the only value elements that may be empty, all others must contain data. See the <a
                            href="#the-dataflow-element" class="internalDFN">dataflow</a>
                    element for example usage.
                </dd>
                <dt>attribute float key</dt>
                <dd>A keyframe value to assist in defining animated values. A script may, for example, interpolate the
                    data between successive keys.
                </dd>

                <dt>void setScriptValue(Float32Array value)</dt>
                <dd>
                    A high performance setter to set the data of this value element directly through JavaScript.
                </dd>
            </dl>

        </section>
        <section>

<!-- #int -->

            <h4>The <code>int</code> and <code>int4</code> elements</h4>
            <dl class='element'>
                <dt>Categories:</dt>
                <dd><a href="#value-elements">Value element</a></dd>
            </dl>
            <p>The <code>int*</code> elements hold a space separated list of integer values. The tag name determines how
                this data is interpreted, ie. an <code>int4</code> element
                will interpret the data as an array of 4-component integer vectors. </p>
            <dl title='interface XML3DIntValueElement : HTMLElement' class='idl'>
                <dt>attribute DOMString name</dt>
                <dd>The name of the value element. A good name should be a semantic description of the data that this
                    element holds.
                </dd>
                <dt>attribute boolean param</dt>
                <dd>Marks this value as one to be supplied by a different data element. Value elements with the <code>param</code>
                    attribute are
                    the only value elements that may be empty, all others must contain data. See the <a
                            href="#the-dataflow-element" class="internalDFN">dataflow</a>
                    element for example usage.
                </dd>
                <dt>attribute float key</dt>
                <dd>A keyframe value to assist in defining animated values. A script may, for example, interpolate the
                    data between successive keys.
                </dd>

                <dt>void setScriptValue(Int16Array value)</dt>
                <dd>
                    A high performance setter to set the data of this value element directly through JavaScript.
                </dd>
            </dl>
        </section>
        <section>

<!-- #bool -->

            <h4>The <code>bool</code> element</h4>
            <dl class='element'>
                <dt>Categories:</dt>
                <dd><a href="#value-elements">Value element</a></dd>
            </dl>
            <p>The <dfn>bool element</dfn> holds a space separated list of boolean values. The values may be given in
                string form (<code>true/false</code>) or as integers (<code>1/0</code>). </p>

            <dl title='interface XML3DBoolValueElement : HTMLElement' class='idl'>
                <dt>attribute DOMString name</dt>
                <dd>The name of the value element. A good name should be a semantic description of the data that this
                    element holds.
                </dd>
                <dt>attribute boolean param</dt>
                <dd>Marks this value as one to be supplied by a different data element. Value elements with the <code>param</code>
                    attribute are
                    the only value elements that may be empty, all others must contain data. See the <a
                            href="#the-dataflow-element" class="internalDFN">dataflow</a>
                    element for example usage.
                </dd>
                <dt>attribute float key</dt>
                <dd>A keyframe value to assist in defining animated values. A script may, for example, interpolate the
                    data between successive keys.
                </dd>

                <dt>void setScriptValue(Int16Array value)</dt>
                <dd>
                    A high performance setter to set the data of this value element directly through JavaScript.
                </dd>
            </dl>
        </section>
        <section>

<!-- #string -->

            <h4>The <code>string</code> element</h4>
            <dl class='element'>
                <dt>Categories:</dt>
                <dd><a href="#value-elements">Value element</a></dd>
            </dl>
            <p>The <dfn>string element</dfn> holds a <em>comma</em> separated list of string values.
            </p>

            <p>Currently the following string attributes may be supplied by including a string element with the matching
                <code>name</code>:</p>
            <ul>
                <li>The <a href="#attr-mesh-type" class="internalDFN">type attribute</a> of the <a>mesh element</a></li>
                <li>The <a href="#attr-mesh-type" class="internalDFN">type attribute</a> of the <a>assetmesh element</a>
                </li>
            </ul>
            <p>Below is an example using a custom Xflow operator to change the type attribute of a <a>mesh element</a>:
            </p>

      <pre class="example highlight">
          &lt;!-- The custom xflow operator will output a string field named 'type' --&gt;
          &lt;data id="meshTypeCompute" compute="type = xflow.selectString(selector, value1, value2)"&gt;
              &lt;string name="value1"&gt;triangles&lt;/string&gt;
              &lt;string name="value2"&gt;lines&lt;/string&gt;
              &lt;int name="selector"&gt;2&lt;/int&gt;
          &lt;/data&gt;

          &lt;!-- In this case type will evaluate to 'lines' --&gt;
          &lt;mesh src="#meshdata" type="derived"&gt;
            &lt;data src="#meshTypeCompute"&gt;&lt;/data&gt;
          &lt;/mesh&gt;
      </pre>

            <dl title='interface XML3DStringValueElement : HTMLElement' class='idl'>
                <dt>attribute DOMString name</dt>
                <dd>The name of the value element. A good name should be a semantic description of the data that this
                    element holds.
                </dd>
                <dt>attribute boolean param</dt>
                <dd>Marks this value as one to be supplied by a different data element. Value elements with the <code>param</code>
                    attribute are
                    the only value elements that may be empty, all others must contain data. See the <a
                            href="#the-dataflow-element" class="internalDFN">dataflow</a>
                    element for example usage.
                </dd>
                <dt>attribute float key</dt>
                <dd>A keyframe value to assist in defining animated values. A script may, for example, interpolate the
                    data between successive keys.
                </dd>

                <dt>void setScriptValue(Array value)</dt>
                <dd>
                    A high performance setter to set the data of this value element directly through JavaScript.
                </dd>
            </dl>
        </section>


<!-- #texture -->
        <section>
            <h4>The <code>texture</code> element</h4>
            <dl class='element'>
                <dt>Categories:</dt>
                <dd><a href="#value-elements">Value element</a></dd>
                <dt>Content model:</dt>
                <dd>One or more <code>img</code>, <code>video</code>, or <code>canvas</code> elements</dd>
            </dl>

            The <dfn>texture element</dfn> represents a texture that can be used as parameter for materials or as input
            for generic
            dataflow processing.
            The image data of the texture is defined by its children.
            The texture element's attributes determine how samples are derived from the image.
            <p class="note">
                Texture sampling attributes configure fixed-function sampling methods on the graphics hardware.
                Thus these attributes qualify as CSS properties. We have abstained from using CSS properties because we
                currently cannot define custom CSS properties.
            </p>


            <div>The <dfn id="attr-texture-wrap">wrap</dfn> attribute controls the texture access if the provided
                texture
                coordinates are outside range [0;1]. The wrap attribute is a combined enumerated attribute.
                A valid wrap value is a string that matches the <code>wrap</code> production of the following form:
      <pre>
        wrap := &lt;wrap-mode&gt; &lt;wrap-mode&gt;?
        wrap-mode := repeat | clamp
      </pre>
                If two <code>wrap-mode</code> values are given, then the first value defines the wrap mode for s
                coordinates and
                the second for t coordinates. Otherwise the wrap mode is applied in all directions.
                The wrap-mode values correspond to CLAMP_TO_EDGE and REPEAT in OpenGL.

            </div>
            <br>

            <div>The <dfn id="attr-texture-filter">filter</dfn> attribute controls the filtering of the texture, i.e.
                which
                texture pixel access function is used. The <code>wrap</code> attribute is a combined enumerated
                attribute.
                A valid filter value is a string that matches the filter production of the following form:
      <pre>
        filter := (&lt;min-filter-mode&gt; &lt;mag-filter-mode&gt;) | &lt;mag-filter-mode&gt;
        min-filter-mode := nearest | linear | nearest-mipmap-nearest | nearest-mipmap-linear | linear-mipmap-nearest | linear-mipmap-linear
        mag-filter-mode := nearest | linear
      </pre>
                If only the <code>mag-filter-mode</code> is given, the specified function is used for both, minifying
                and
                magnification. Otherwise, the <code>min-filter-mode</code> is used for minifying and the
                <code>mag-filter-mode</code> is used for magnification.
                The functions specified by the filter modes correspond to those in OpenGL (NEAREST, LINEAR,
                NEAREST_MIPMAP_NEAREST, NEAREST_MIPMAP_LINEAR, LINEAR_MIPMAP_NEAREST, and LINEAR_MIPMAP_LINEAR).
                The default filter mode is "linear-mipmap-linear linear".
            </div>

            <p class="note">
                xml3d.js will automatically resize textures to the nearest power-of-two dimensions when the texture wrap
                mode is
                set to "repeat" or filtermin is set to anything other than "nearest" or
                "linear". See <a
                    href="https://www.khronos.org/webgl/wiki/WebGL_and_OpenGL_Differences#Non-Power_of_Two_Texture_Support">WebGL
                limitations</a> for more information.
            </p>

            Here is an example of using the <code>wrap</code> and <code>filter</code> attributes to configure the
            sampling of a texture:
      <pre class="example highlight">
        &lt;texture name=&quot;diffuseTexture&quot; wrap=&quot;repeat clamp&quot; filter=&quot;nearest linear&quot;&gt;
          &lt;img src=&quot;../stone.jpg&quot;/&gt;
        &lt;/texture&gt;
      </pre>

            The <dfn id="attr-texture-type">type</dfn> attribute is an <a
                href="http://www.w3.org/TR/html5/single-page.html#enumerated-attribute">enumerated attribute</a> with
            four states with three explicit keywords:
            <dl>
                <dt>The <dfn id="attr-texture-type-1d">1D</dfn> keyword, which maps to the <i>1D</i> state</dt>
                <dd>The 1D state means the children elements define a 1D texture each.</dd>
                <dt>The <dfn id="attr-texture-type-2d">2D</dfn> keyword, which maps to the <i>2D</i> state</dt>
                <dd>The 2D state means the children elements defines a 2D texture.</dd>
                <dt>The <dfn id="attr-texture-type-3d">3D</dfn> keyword, which maps to the <i>3D</i> state</dt>
                <dd>The 3D state means the children elements defines a 3D texture.</dd>
                <dt>The <i>auto</i> state</dt>
                <dd>The type of the texture is determined by the system based on the texture's children elements.</dd>
            </dl>
            <p>The <code><a href="#attr-texture-type" class="internalDFN">type</a></code> attribute's <i>missing value
                default</i> is the <i>auto</i> state.</p>


            <dl title='interface XML3DTextureElement : HTMLElement' class='idl'>
                <dt>attribute DOMString wrap</dt>
                <dd>The <code>wrap</code> IDL attribute must reflect the respective content attribute of the same name.
                </dd>
                <dt>attribute DOMString filter</dt>
                <dd>The <code>filter</code> IDL attribute must reflect the respective content attribute of the same
                    name.
                </dd>
                <dt>attribute DOMString name</dt>
                <dd>Required. The name of the texture as defined by the material shader.</dd>
                <dt>attribute boolean param</dt>
                <dd>If this element appears inside a DataFlow element the param attribute will mark it as a parameter to
                    be
                    supplied by the Data element referencing the DataFlow.
                </dd>
                <dt>attribute DOMString type</dt>
                <dd>The <code>type</code> IDL attribute must reflect the content attribute of the same name, <a
                        href="http://www.w3.org/TR/html5/single-page.html#limited-to-only-known-values">limited to only
                    known values</a>.
                </dd>
            </dl>
        </section>


    </section>

</section>

<section>
    <h2>Predefined models</h2>
    <section>
        <h3>Predefined primitive types</h3>
        <section>
            <h2>Triangle</h2>

            <p>Attribute name: <code>triangles</code></p>

            <p>WebGL primitive: <code>TRIANGLE</code></p>

            <div class="attributes">Parameters:
                <table>
                    <tbody>
                    <tr>
                        <th>Name</th>
                        <th>Type</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td>index</td>
                        <td>int</td>
                        <td>A list of indicies to build triangles out of.</td>
                    </tr>
                    </tbody>
                </table>
            </div>

            <p>The triangle primitive type renders faces out of sets of 3 vertices. Triangles may be constructed with or
                without an array of indices. If no indices are provided
                XML3D will construct the triangles from the array of vertex positions: the first 3 will create the first
                triangle, the next 3 the second and so on.</p>

      <pre class="example highlight">
        &lt;mesh type="triangles"&gt;
          &lt;int name="index"&gt;0 1 2 1 3 2 ... &lt;/int&gt;
          &lt;float3 name="position"&gt;-1 -1 1  1 -1 1  -1 1 1  1 1 1 ... &lt;/float3&gt;
        &lt;/mesh&gt;
      </pre>

        </section>

        <section>
            <h2>Tristrip</h2>

            <p>Attribute name: <code>tristrips</code></p>

            <p>WebGL primitive: <code>TRIANGLE_STRIP</code></p>

            <div class="attributes">Parameters:
                <table>
                    <tbody>
                    <tr>
                        <th>Name</th>
                        <th>Type</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td>index</td>
                        <td>int</td>
                        <td>A list of indicies to build tristrips out of.</td>
                    </tr>
                    <tr>
                        <td>vertexCount</td>
                        <td>int</td>
                        <td>The number of vertices or indices to use for each tristrip segment.</td>
                    </tr>
                    </tbody>
                </table>
            </div>

            <p>The tristrip primitive type creates triangles from a list of vertex positions and (optionally) a list of
                segments and/or indices. Each segment begins by building a triangle
                out of 3 vertex positions. Each subsequent triangle in the segment is then created from the last two
                vertex positions and the next one in the list. Note that this
                creates a sequence of connected triangles.</p>

            <p>Segments can be used to create disconnected sets of triangles by providing a list of integers with the
                name <code>vertexCount</code>. Each number in the list
                specifies the number of vertex positions to use for that segment. XML3D will then work through the list
                of vertex positions sequentially building a tristrip for each segment. </p>

      <pre class="example highlight">
        &lt;mesh type="tristrips"&gt;
          &lt;int name="vertexCount"&gt;4 4 4 4 4 4&lt;/int&gt;
          &lt;float3 name="position"&gt;-1 -1 1  1 -1 1  -1 1 1  1 1 1 ... &lt;/float3&gt;
        &lt;/mesh&gt;
      </pre>

            <p>Note that because the first triangle in a segment requires 3 vertex positions to define, a segment with
                vertex count 4 will create two triangles, while vertex
                count 5 will create 3 and so on.</p>
        </section>

        <section>
            <h2>Line</h2>

            <p>Attribute name: <code>lines</code></p>

            <p>WebGL primitive: <code>LINES</code></p>

            <div class="attributes">Parameters:
                <table>
                    <tbody>
                    <tr>
                        <th>Name</th>
                        <th>Type</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td>index</td>
                        <td>int</td>
                        <td>A list of indicies to build lines out of.</td>
                    </tr>
                    </tbody>
                </table>
            </div>

            <p>Lines are drawn from pairs of vertex positions and (optionally) a list of indices. </p>
        </section>

        <section>
            <h2>Linestrip</h2>

            <p>Attribute name: <code>linestrips</code></p>

            <p>WebGL primitive: <code>LINE_STRIP</code></p>

            <div class="attributes">Parameters:
                <table>
                    <tbody>
                    <tr>
                        <th>Name</th>
                        <th>Type</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td>index</td>
                        <td>int</td>
                        <td>A list of indicies to build linestrips out of.</td>
                    </tr>
                    <tr>
                        <td>vertexCount</td>
                        <td>int</td>
                        <td>The number of vertices or indices to use for each linestrip segment.</td>
                    </tr>
                    </tbody>
                </table>
            </div>

            <p>A linestrip is drawn from a list of vertex positions and (optionally) a list of segments and/or indices.
                For each segment a line is drawn between the first vertex and
                the second, then the second and the third and so on. This creates a continuous line.</p>

      <pre class="example highlight">
      &lt;mesh type="linestrips"&gt;
        &lt;int name="vertexCount"&gt;4 2&lt;/int&gt;
        &lt;int name="index"&gt;0 1 2 3 1 3&lt;/int&gt;
        &lt;float3 name="position"&gt;-1 -1 1  1 -1 1  -1 1 1  1 1 1 ... &lt;/float3&gt;
      &lt;/mesh&gt;
      </pre>

            <p>The above example will create two line segments, the first using vertices 0, 1, 2, 3 and the second using
                vertices 1 and 3. </p>

        </section>

        <section>
            <h2>Point</h2>

            <p>Attribute name: <code>points</code></p>

            <p>WebGL primitive: <code>POINT</code></p>

            <p>Points are drawn from a list of vertex positions, which each position being drawn as a single point.</p>

            <div class="note">Currently to change the size of the drawn points, or to draw them as textured sprites, it
                is necessary to define a custom material shader.
            </div>
        </section>

        <section>
            <h2>Derived</h2>

            <p>Attribute name: <code>derived</code></p>

            <p>The special primitive type derived delegates the evaluation of the primitive type to the generic data
                model.
                The requested parameter has the name <code>type</code>. The contained value needs to match one of the
                primitive types above.
            </p>
        <pre class="example highlight">
      &lt;mesh type="derived"&gt;
        &lt;string name="type"&gt;triangles&lt;/string&gt;
        ...
      &lt;/mesh&gt;
      </pre>

        </section>

    </section>
    <section>
        <h3>Predefined material models</h3>

        <section>
            <h2>Matte</h2>

            <p>URN: <code>urn:xml3d:material:matte</code></p>

            <div class="attributes">Parameters:
                <table>
                    <tbody>
                    <tr>
                        <th>Name</th>
                        <th>Type</th>
                        <th>Default</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td>diffuseColor</td>
                        <td>float3</td>
                        <td>1 1 1</td>
                        <td>The objects RGB color</td>
                    </tr>
                    <tr>
                        <td>useVertexColor</td>
                        <td>bool</td>
                        <td>false</td>
                        <td>if true, the vertex attribute 'color' is used to color the object.</td>
                    </tr>
                    </tbody>
                </table>
            </div>
            <p>
                Simple material that does not apply any lighting but shades the object with a single uniform color
                defined by
                the <code>diffuseColor</code> parameter or by the
                vertex attribute <code>color</code>, if <code>useVertexColor</code> is set to ''true''.
            </p>
        </section>

        <section>
            <h2>Diffuse</h2>

            <p>URN: <code>urn:xml3d:material:diffuse</code></p>

            <div class="attributes">Parameters:
                <table>
                    <tbody>
                    <tr>
                        <th>Name</th>
                        <th>Type</th>
                        <th>Default</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td>diffuseColor</td>
                        <td>float3</td>
                        <td>1 1 1</td>
                        <td>The object's RGB diffuse color component.</td>
                    </tr>
                    <tr>
                        <td>diffuseTexture</td>
                        <td>texture</td>
                        <td><i>undefined</i></td>
                        <td>Texture to read the diffuse color component and opacity (alpha) from. Accessed based on <code>texcoord</code> per-vertex attribute.
                          If <i>diffuseTexture</i> is defined, the rgb channel of the <i>diffuseTexture</i> gets multiplied with the current <code>diffuseColor</code> and the the alpha channel
                          gets multiples with the current <code>opacity</code>.
                        </td>
                    </tr>

                    <tr>
                        <td>emissiveColor</td>
                        <td>float3</td>
                        <td>0 0 0</td>
                        <td>The object's RGB emissive color component.</td>
                    </tr>
                    <tr>
                        <td>emissiveTexture</td>
                        <td>texture</td>
                        <td><i>undefined</i></td>
                        <td>Texture to read the emissive color component from. Accessed based on <code>texcoord</code> per-vertex attribute.
                          If <i>emissiveTexture</i> is defined, the <code>emissiveColor</code> gets multiplied with the color accessed from the texture.
                        </td>
                    </tr>
                    <tr>
                        <td>ambientIntensity</td>
                        <td>float</td>
                        <td>0</td>
                        <td>The amount of the 'diffuseColor' to be added to the shading without considering lighting.
                        </td>
                    </tr>
                    <tr>
                        <td>opacity</td>
                        <td>float</td>
                        <td>1</td>
                        <td>The opacity of the object, with 1 being opaque and 0 being fully transparent.</td>
                    </tr>
                    <tr>
                        <td>useVertexColor</td>
                        <td>bool</td>
                        <td>false</td>
                        <td>Setting <i>useVertexColor</i> to 'true', the vertex attribute <code>color</code> will be multiplied to
                            the diffuse color component (before the <code>diffuseTexture</code> gets applied).
                        </td>
                    </tr>
                    </tbody>
                </table>
            </div>
            <p>
              The <dfn>diffuse material model</dfn> describes a diffuse surfaces that reflects light equally in all
              directions. Additionally, the surface has an optional emissive and ambient component. This is the logic
              of the diffuse material model in JavaScript/shade.js pseudo code:
            </p>
      <pre class="highlight">
        function shade(env) {
          var diffuseColor = env.diffuseColor || new Vec3(1, 1, 1);
          var emissiveColor = env.emissiveColor || new Vec3(0);
          var opacity = Math.max(1, env.opacity);

          if (env.useVertexColor && env.color) {
            diffuseColor *= new Vec3(env.color);
          }

          if (env.diffuseTexture && env.diffuseTexture.sample2D) {
             var texDiffuse = env.diffuseTexture.sample2D(env.texcoord);
             diffuseColor *= texDiffuse.rgb();
             opacity *= texDiffuse.a();
          }

          if (env.emissiveTexture && env.emissiveTexture.sample2D) {
             var texEmissive = env.emissiveTexture.sample2D(env.texcoord);
             emissiveColor *= texEmissive.rgb();
          }

          return Shade.diffuse(diffuseColor, env.normal)
                      .transparent(1.0 - opacity)
                      .emissive(emissiveColor);
        }
      </pre>

        </section>

        <section>
            <h2>Phong</h2>

            <p>URN: <code>urn:xml3d:material:phong</code></p>

            <div class="attributes">Parameters:
                <table>
                    <tbody>
                    <tr>
                        <th>Name</th>
                        <th>Type</th>
                        <th>Default</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td>diffuseColor</td>
                        <td>float3</td>
                        <td>1 1 1</td>
                        <td>The object's RGB diffuse color component.</td>
                    </tr>
                    <tr>
                      <td>diffuseTexture</td>
                      <td>texture</td>
                      <td><i>undefined</i></td>
                      <td>Texture to read the diffuse color component and opacity (alpha) from. Accessed based on <code>texcoord</code>
                        per-vertex attribute.
                        If <i>diffuseTexture</i> is defined, the rgb channel of the <i>diffuseTexture</i> gets
                        multiplied with the current <code>diffuseColor</code> and the the alpha channel
                        gets multiples with the current <code>opacity</code>.
                      </td>
                    </tr>
                    <tr>
                        <td>specularColor</td>
                        <td>float3</td>
                        <td>0 0 0</td>
                        <td>The object's RGB specular color component.</td>
                    </tr>
                    <tr>
                        <td>specularTexture</td>
                        <td>texture</td>
                        <td><i>undefined</i></td>
                        <td>Texture to read the specular color component from. Accessed based on <code>texcoord</code> per-vertex attribute.
                          If <i>specularTexture</i> is defined, the <code>specularColor</code> gets multiplied with the rgb-color accessed from the texture.
                        </td>
                    </tr>
                    <tr>
                        <td>shininess</td>
                        <td>float</td>
                        <td>0.5</td>
                        <td>A scalar for the object's specular exponent, to be multiplied by 128 (e.g. a value of 0.5
                            will give a specular exponent of 64)
                        </td>
                    </tr>
                    <tr>
                        <td>emissiveColor</td>
                        <td>float3</td>
                        <td>0 0 0</td>
                        <td>The object's RGB emissive color component.</td>
                    </tr>
                    <tr>
                        <td>emissiveTexture</td>
                        <td>texture</td>
                        <td><i>undefined</i></td>
                        <td>Texture to read the emissive color component from. Accessed based on <code>texcoord</code> per-vertex attribute.
                          If <i>emissiveTexture</i> is defined, the <code>emissiveColor</code> gets multiplied with the rgb-color accessed from the texture.
                        </td>
                    </tr>
                    <tr>
                        <td>ambientIntensity</td>
                        <td>float</td>
                        <td>0</td>
                        <td>The amount of the 'diffuseColor' to be added to the shading without considering lighting.
                        </td>
                    </tr>
                    <tr>
                        <td>opacity</td>
                        <td>float</td>
                        <td>1</td>
                        <td>The opacity of the object, with 1 being opaque and 0 being fully transparent.</td>
                    </tr>
                    <tr>
                        <td>useVertexColor</td>
                        <td>bool</td>
                        <td>false</td>
                        <td>Setting <i>useVertexColor</i> to 'true', the vertex attribute 'color' will be multiplied to
                            the diffuse
                            color component.
                        </td>
                    </tr>
                    </tbody>
                </table>
            </div>
          <p>
            The <dfn>phong material model</dfn> extends the <a>diffuse material model</a> by the specular term from the Phong reflection
            model. The additional parameters are specularColor, specularTexture and shininess.
            This is the logic of the phong material model in JavaScript/shade.js pseudo code:
          </p>
          <pre class="highlight">
        function shade(env) {
          var diffuseColor = env.diffuseColor || new Vec3(1, 1, 1);
          var specularColor = env.specularColor || new Vec3(0, 0, 0);
          var emissiveColor = env.emissiveColor || new Vec3(0);
          var opacity = Math.max(1, env.opacity);
          var shininess = env.shininess != undefined ? env.shininess : 0.5;

          if (env.useVertexColor && env.color) {
            diffuseColor *= new Vec3(env.color);
          }

          if (env.diffuseTexture && env.diffuseTexture.sample2D) {
             var texDiffuse = env.diffuseTexture.sample2D(env.texcoord);
             diffuseColor *= texDiffuse.rgb();
             opacity *= texDiffuse.a();
          }

          if (env.specularTexture && env.specularTexture.sample2D) {
             var texSpecular = env.specularTexture.sample2D(env.texcoord);
             diffuseColor *= texSpecular.rgb();
          }

          if (env.emissiveTexture && env.emissiveTexture.sample2D) {
             var texEmissive = env.emissiveTexture.sample2D(env.texcoord);
             emissiveColor *= texEmissive.rgb();
          }


          return Shade.diffuse(diffuseColor, env.normal)
                      .phong(specularColor, env.normal, shininess)
                      .transparent(1.0 - opacity)
                      .emissive(emissiveColor);
        }
      </pre>
        </section>
    </section>

    <section>
        <h3>Predefined light models</h3>
        <section>
            <h2>Point Lights</h2>

            <p>URN: <code>urn:xml3d:light:point</code></p>

            <div class="attributes">Parameters:
                <table>
                    <tbody>
                    <tr>
                        <th>Name</th>
                        <th>Type</th>
                        <th>Default</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td>position</td>
                        <td>float3</td>
                        <td>0 0 0</td>
                        <td>The position of the point light in object space</td>
                    </tr>
                    <tr>
                        <td>attenuation</td>
                        <td>float3</td>
                        <td>0 0 1</td>
                        <td>The attenuation of the point light given as its constant, linear, e.g quadratic component.
                        </td>
                    </tr>
                    <tr>
                        <td>intensity</td>
                        <td>float3</td>
                        <td>1 1 1</td>
                        <td>The RGB intensity of the point light.</td>
                    </tr>
                    </tbody>
                </table>
            </div>
            <p>
                Point light sources emit light from a single point in space with a uniform distribution in all
                directions, i.e. omnidirectional.
                The position of the point light is defined by its <i>position</i> attribute and affected by the
                transformation of the light element that defines
                the occurrence of the point light. The orientation of the light element is not influencing the light.
            </p>
        </section>

        <section>
            <h2>Directional Lights</h2>

            <p>URN: <code>urn:xml3d:light:directional</code></p>

            <div class="attributes">Parameters:
                <table>
                    <tbody>
                    <tr>
                        <th>Name</th>
                        <th>Type</th>
                        <th>Default</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td>direction</td>
                        <td>float3</td>
                        <td>0 0 -1</td>
                        <td>The direction of the light in object space.</td>
                    </tr>
                    <tr>
                        <td>intensity</td>
                        <td>float3</td>
                        <td>1 1 1</td>
                        <td>The RGB intensity of the point light.</td>
                    </tr>
                    </tbody>
                </table>
            </div>
            <p>
                Directional light sources, also known as distant light sources, emit light along parallel rays from an
                infinite distance away. The direction the light sources
                emits from is defined by its <i>direction</i> attribute and affected by the transformation of the light
                element that defines
                the occurrence of the distant light. The position of the light element is not taken into account.
            </p>

        </section>

        <section>
            <h2>Spot Lights</h2>

            <p>URN: <code>urn:xml3d:light:spot</code></p>

            <div class="attributes">Parameters:
                <table>
                    <tbody>
                    <tr>
                        <th>Name</th>
                        <th>Type</th>
                        <th>Default</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td>position</td>
                        <td>float3</td>
                        <td>0 0 0</td>
                        <td>The position of the point light in object space</td>
                    </tr>
                    <tr>
                        <td>direction</td>
                        <td>float3</td>
                        <td>0 0 -1</td>
                        <td>The direction of the light in object space.</td>
                    </tr>
                    <tr>
                        <td>intensity</td>
                        <td>float3</td>
                        <td>1 1 1</td>
                        <td>The <i>RGB</i> intensity of the directional light.</td>
                    </tr>
                    <tr>
                        <td>attenuation</td>
                        <td>float3</td>
                        <td>0 0 1</td>
                        <td>The attenuation of the point light given as its constant, linear, e.g quadratic component.
                        </td>
                    </tr>
                    <tr>
                        <td>cutoffAngle</td>
                        <td>float</td>
                        <td>Math.PI/4</td>
                        <td>Spot angle in radians. Controls the size of the outer cone of a spot light, i.e. the
                            circular area a spot
                            light covers.
                        </td>
                    </tr>
                    <tr>
                        <td>softness</td>
                        <td>float</td>
                        <td>0</td>
                        <td>Softness of the spot light in the range [0;1].</td>
                    </tr>
                    </tbody>
                </table>
            </div>
            <p>
                Spot light source are a variation of point lights: Instead of emitting light omnidirectional, they emit
                light from their position in a cone of direction.
                The <i>cutoffAngle</i> attribute defines the size of the cone. Objects outside the cone defined by the
                <i>cutoffAngle</i> are not lit by the light source. The <i>softness</i>
                attribute defines the percentage of the cone in which the illumination ramps down from full to no
                illumination, i.e. a softness of 0 specifies a hard transition between full
                to no illumination and a softness of 1.0 a linear transition along the radius of the cone.
            </p>
        </section>
    </section>
    <section>
        <h3>Predefined view models</h3>
        This section describes the currently available <dfn>predefined view models</dfn>.
        <section>
            <h4>Perspective</h4>

            <p>URN: <code>urn:xml3d:view:perspective</code></p>

            <div class="attributes">Parameters:
                <table>
                    <tbody>
                    <tr>
                        <th>Name</th>
                        <th>Type</th>
                        <th>Default</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td>fovVertical</td>
                        <td>float</td>
                        <td>Math.PI / 4</td>
                        <td>The vertical field of view of the view frustum in radians</td>
                    </tr>
                    <tr>
                        <td>fovHorizontal</td>
                        <td>float</td>
                        <td>-</td>
                        <td>The horizontal field of view of the view frustum in radians</td>
                    </tr>
                    <tr>
                        <td>near</td>
                        <td>float</td>
                        <td>-</td>
                        <td>The distance of the near clipping plane (unitless)</td>
                    </tr>
                    <tr>
                        <td>far</td>
                        <td>float</td>
                        <td>-</td>
                        <td>The distance of the far clipping plane (unitless)</td>
                    </tr>
                    </tbody>
                </table>
            </div>
            <p>
                The <dfn>perspective view model</dfn> defines a perspective view frustum based on the near and far
                planes and on a vertical or horizontal opening angle.
                A small field of view roughly corresponds to a telephoto lens; a large field of view roughly corresponds
                to a wide-angle lens.
                If fovHorizontal is given, the frustum is defined using this horizontal angle, otherwise fovVertical is
                used.
                If the far or the near clipping place is not defined, the system will try to compute a useful value
                automatically based on the scene's dimension.
            </p>
        </section>
        <section>
            <h4>Projective</h4>

            <p>URN: <code>urn:xml3d:view:projective</code></p>

            <div class="attributes">Parameters:
                <table>
                    <tbody>
                    <tr>
                        <th>Name</th>
                        <th>Type</th>
                        <th>Default</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td>projectionMatrix</td>
                        <td>float4x4</td>
                        <td></td>
                        <td>The frustum described as projection matrix</td>
                    </tr>
                    </tbody>
                </table>
            </div>
            <p>
                The <dfn>projective view model</dfn> defines a projective view frustum based on a projection matrix.
                This view model is typically used, if the
                intrisic camera parameters are computed, e.g. from a webcam image using computer vision algorithms.
            </p>
        </section>
    </section>

</section>


<section>
    <h2>Custom materials</h2>

    <p>XML3D provides an interface to define custom materials in addition to the predefined material models. Such
        materials must first be registered
        with XML3D:</p>
    <pre class="example highlight">
        XML3D.materials.register("my-material", { ...material definition... });
    </pre>
    <p>and may then be referenced through the <a href="#attr-material-model">model</a> attribute of a <a>material
        element</a>:</p>
    <pre class="example highlight">
        &lt;material model="urn:xml3d:materials:my-material"&gt;&lt;/material&gt;
    </pre>
    <p>The material definition must provide vertex and fragment shader code in the form of a string as well as
        definitions and default
        values for all uniform and sampler variables:</p>
    <pre class="example highlight">
        XML3D.materials.register("my-material", {
            vertex : "...vertex shader code...",
            fragment : "...fragment shader code...",

            //All uniform variables that appear in either shader block, with default values
            uniforms : {
                exampleFloat : 0.5,
                exampleVec3  : [1, 1, 1]
            },

            //All textures that appear in either shader block
            samplers : {
                exampleTexture : null
            },

            //All vertex attributes that appear in the vertex shader
            attributes : {
                position : {required : true},
                normal : null //Synonymous with {required : false}
                exampleVertexAttribute : {required : false},
            },

            //Optional function to mark this material as requiring alpha blending
            hasTransparency : function(params) {
                return params.opacity && params.opacity.getValue()[0] < 1;
            },

            //Optional function to add compiler directives to shaders based on scene parameters (eg. the number of lights)
            addDirectives : function(directives, lights, params) {
                directives.push("HAS_EXAMPLETEXTURE " + ('exampleTexture' in params ? "1" : "0"));
            }
        });
    </pre>
    <p>As with the predefined material models the generic data model can be used to set material parameters like uniform
        variables and textures for
        custom materials:</p>
    <pre class="example highlight">
        &lt;material model="urn:xml3d:material:my-material"&gt;
            &lt;float3 name="exampleVec3"&gt;0 1 0&lt;/float3&gt;
            &lt;texture name="exampleTexture"&gt;
                &lt;img src="textures/my-example-texture.png"/&gt;
            &lt;/texture&gt;
        &lt;/material&gt;
    </pre>

    <p>Custom materials may also be defined through <a href="https://github.com/xml3d/shade.js">shade.js</a> which is
        generally easier to use
        and is able to generate cross platform materials that may be used outside of XML3D as well.</p>

    <div class="note">
        Be careful with materials that modify the vertex positions of a mesh. These objects will not be pickable and may have
        incorrect bounding boxes, which can lead to incorrect clipping planes and frustum culling in the camera.
        If your material falls into this category you should always provide a reasonable bounding box for the object manually:

    <pre class="example highlight">
    &lt;mesh src="myMesh.xml" material="#my-material"&gt;
        &lt;float3 name="boundingBox"&gt;-10 -10 -10 5 5 5&lt;/float3&gt; &lt;!-- min max points of the bounding box --&gt;
    &lt;/mesh&gt;
    </pre>

    </div>

</section>

<section>
    <h2>Global options</h2>
    <p>XML3D provides a set of global options through the <code>XML3D.options</code> interface. These options are shared between
    all XML3D elements on a page.</p>
    <dl title="interface options" class="idl" id="idl-def-options">
        <dt>string getValue(string key)</dt>
        <dd>Returns the current value of the option with the matching key.</dd>
        <dt>void setValue(string key, string value)</dt>
        <dd>Set the option with the given key to the given value.</dd>
        <dt>Array getKeys()</dt>
        <dd>Returns an array of all available option keys.</dd>
        <dt>void addObserver(string key, function observer)</dt>
        <dd>Adds a change observer to the option with the given key. Supports the '*' wildcard to observe all options.</dd>
        <dt>void removeObserver(function observer)</dt>
        <dd>Removes the given change observer from all keys.</dd>
        <dt>void resetValue(string key)</dt>
        <dd>Resets the value of the option with the matching key to the default value.</dd>
        <dt>void setOptionsFromQuery()</dt>
        <dd>Parses the page URL for option keys and values in the standard query form. Done once automatically on page load.</dd>
    </dl>

    <p>Currently the following options are available in xml3d.js, the default is shown in bold:</p>
    <div class="attributes">
        <table>
            <tbody>
            <tr>
                <th>Key</th>
                <th>Values</th>
                <th>Description</th>
            </tr>
            <tr>
                <td>loglevel</td>
                <td>all, debug, info, warning, <span class="default_option">error</span>, exception</td>
                <td>Controls the level of logging to the console.</td>
            </tr>
            <tr>
                <td>resource-crossorigin-attribute</td>
                <td><span class="default_option">anonymous</span>, use-credentials</td>
                <td>This value will be assigned to the <code>crossOrigin</code> field of requested resources such as
                    <code>img</code> or <code>video</code>.</td>
            </tr>
            <tr>
                <td>renderer-faceculling</td>
                <td>back, front, both, <span class="default_option">none</span></td>
                <td>Controls which faces are culled during rendering. Corresponds to WebGL's <code>cullFace</code> function.</td>
            </tr>
            <tr>
                <td>renderer-frontface</td>
                <td>cw, <span class="default_option">ccw</span></td>
                <td>Controls the winding order of polygon faces during rendering. Corresponds to WebGL's <code>frontFace</code> function.</td>
            </tr>
            <tr>
                <td>renderer-frustum-culling</td>
                <td><span class="default_option">true</span>, false</td>
                <td>Toggles <a href="http://www.lighthouse3d.com/tutorials/view-frustum-culling/">view frustum culling</a> during rendering.</td>
            </tr>
            <tr>
                <td>renderer-mousemove-picking</td>
                <td><span class="default_option">true</span>, false</td>
                <td>Enable object picking for mousemove events. Ex: The XML3D standard camera disables mousemove picking between the
                mousedown and mouseup events of a camera rotation.</td>
            </tr>
            <tr>
                <td>renderer-movement-aware-click-handler</td>
                <td>true, <span class="default_option">false</span></td>
                <td>When true, disregard click events where the mouse has moved between the mousedown and mouseup events.</td>
            </tr>
            <tr>
                <td>renderer-continuous</td>
                <td>true, <span class="default_option">false</span></td>
                <td>Toggle continuous rendering. If false a frame will only be drawn if XML3D detects a scene change that requires it.</td>
            </tr>
            <tr>
                <td>renderer-ssao</td>
                <td>true, <span class="default_option">false</span></td>
                <td>Toggle screen space ambient occlusion. Note: This is an experimental feature!</td>
            </tr>

            </tbody>
        </table>
    </div>

    <div class="note">
        These options can also be set through URL queries by appending <code>xml3d-</code>, like so: <code>?xml3d-loglevel=debug</code>
    </div>

</section>

<section>
    <h2>Content-Types</h2>

    <p>XML3D specifies the following content-types for external resources:</p>
    <pre>
        JSON mesh file     model/vnd.xml3d.mesh+json

        XML mesh file      model/vnd.xml3d.mesh+xml

        XML asset file     model/vnd.xml3d.model+xml
    </pre>
    <p>The response should include a <code>Content-Type</code> header with the same content-type <b>or</b> the
        appropriate standard type
        <code>application/json</code>, <code>application/xml</code> or <code>application/octet-stream</code>. </p>

    <div class="note">A response with no <code>Content-Type</code> header at all <em>will not be handled</em> and will
        generate an error message.
    </div>
</section>


<section>
    <h2>Datatypes</h2>

    <p>XML3D provides a range of math types based on the <a href="http://glmatrix.net/">glMatrix</a> library. In general
        the functions they provide are
        immutable, with the exception of the <code>Box</code> and <code>Ray</code> types. </p>


    <section>
        <h3>Vec2</h3>
        <dl class='element'>
        </dl>
        <p>A two component vector object.</p>

        <dl title='interface Vec2' class='idl' id="idl-def-Vec2">
            <dt>attribute Float32Array data</dt>
            <dd>The underlying typed array that this Vec2 wraps.</dd>
            <dt>attribute float x</dt>
            <dd>Provides mutable access to the first component of this vector.</dd>
            <dt>attribute float y</dt>
            <dd>Provides mutable access to the second component of this vector.</dd>
            <dt>static Vec2 fromDOMString(DOMString str)</dt>
            <dd>Creates a new Vec2 object from the space-separated string representation as used in XML3D element
                attributes.
            </dd>
            <dt>DOMString toDOMString(Vec2 vec)</dt>
            <dd>Converts a Vec2 into the space-seperated string representation used in XML3D element attributes.</dd>

            <dt>Constructor ()</dt>
            <dd>Creates a new identity Vec2 <code>[0,0]</code></dd>
            <dt>Constructor (float x, float y)</dt>
            <dd>Creates a new Vec2 from the given values.</dd>
            <dt>Constructor (Float32Array other)</dt>
            <dd>Creates a new Vec2 which is a copy of the values in the passed array.</dd>
            <dt>Constructor (Vec2 other)</dt>
            <dd>Creates a new Vec2 which is a copy of the given Vec2.</dd>

            <dt>Vec2 add(Vec2 other)</dt>
            <dd>Returns the component wise addition of the two vectors as a new Vec2.</dd>
            <dt>Vec2 clone()</dt>
            <dd>Returns a new copy of this Vec2.</dd>
            <dt>float dist(Vec2 other)</dt>
            <dd>The distance between this and the given vector.</dd>
            <dt>Vec2 divide(Vec2 other)</dt>
            <dd>Returns the component wise division of the two vectors as a new Vec2.</dd>
            <dt>float dot(Vec2 other)</dt>
            <dd>The dot product of this and the given vector.</dd>
            <dt>float length()</dt>
            <dd>Returns the length of this vector.</dd>
            <dt>Vec2 lerp()</dt>
            <dd>Returns a linear interpolation between the two vectors as a new Vec2.
                <dl class='parameters'>
                    <dt>Vec2 other</dt>
                    <dd></dd>
                    <dt>float weight</dt>
                    <dd>Interpolation amount between the two vectors, range of [0,1].</dd>
                </dl>
            </dd>
            <dt>Vec2 max(Vec2 other)</dt>
            <dd>Returns a new Vec2 that contains the component wise maximum of the two vectors.</dd>
            <dt>Vec2 min(Vec2 other)</dt>
            <dd>Returns a new Vec2 that contains the component wise minimum of the two vectors.</dd>
            <dt>Vec2 mul(Vec2 other)</dt>
            <dd>Returns the component wise multiplication of the two vectors as a new Vec2.</dd>
            <dt>Vec2 mul(Mat2 other)</dt>
            <dd>Returns the transformation of this vector with the given 2x2 matrix as a new Vec2.</dd>
            <dt>Vec2 mul(Mat3 other)</dt>
            <dd>Returns the transformation of this vector with the given 3x3 matrix as a new Vec2. The third vector
                component is implicitly '1'.
            </dd>
            <dt>Vec2 mul(Mat4 other)</dt>
            <dd>Returns the transformation of this vector with the given 4x4 matrix as a new Vec2. The third vector
                component is implicitly '0', the fourth '1'.
            </dd>
            <dt>Vec2 negate()</dt>
            <dd>Returns the component wise negation of this vector as a new Vec2.</dd>
            <dt>Vec2 normalize()</dt>
            <dd>Returns the normalized representation of this vector as a new Vec2.</dd>
            <dt>static Vec2 random(optional float scale)</dt>
            <dd>Generates a random vector with the given scale, or a unit vector if omitted.</dd>
            <dt>Vec2 scale(float scale)</dt>
            <dd>Returns the scaled vector as a new Vec2.</dd>
            <dt>Vec2 sub(Vec2 other)</dt>
            <dd>Returns the component wise subtraction of the two vectors as a new Vec2.</dd>

            <dt>static Vec2 wrap(Float32Array data)</dt>
            <dd>Returns a new Vec2 wrapper around the given Float32Array. Note: Changes to the returned Vec2 will also
                change the data in the array!
            </dd>
        </dl>
    </section>
    <section>
        <h3>Vec3</h3>
        <dl class='element'>
        </dl>
        <p>A three component vector object.</p>

        <dl title='interface Vec3' class='idl' id="idl-def-Vec3">
            <dt>attribute Float32Array data</dt>
            <dd>The underlying typed array that this Vec3 wraps.</dd>
            <dt>attribute float x</dt>
            <dd>Provides mutable access to the first component of this vector.</dd>
            <dt>attribute float y</dt>
            <dd>Provides mutable access to the second component of this vector.</dd>
            <dt>attribute float z</dt>
            <dd>Provides mutable access to the third component of this vector.</dd>
            <dt>static Vec3 fromDOMString(DOMString str)</dt>
            <dd>Creates a new Vec3 object from the space-separated string representation as used in XML3D element
                attributes.
            </dd>
            <dt>DOMString toDOMString(Vec3 vec)</dt>
            <dd>Converts a Vec3 into the space-seperated string representation used in XML3D element attributes.</dd>

            <dt>Constructor ()</dt>
            <dd>Creates a new identity Vec3 <code>[0,0,0]</code></dd>
            <dt>Constructor (float x, float y, float z)</dt>
            <dd>Creates a new Vec3 from the given values.</dd>
            <dt>Constructor (Float32Array other)</dt>
            <dd>Creates a new Vec3 which is a copy of the values in the passed array.</dd>
            <dt>Constructor (Vec3 other)</dt>
            <dd>Creates a new Vec3 which is a copy of the given Vec3.</dd>

            <dt>Vec3 add(Vec3 other)</dt>
            <dd>Returns the component wise addition of the two vectors as a new Vec3.</dd>
            <dt>Vec3 clone()</dt>
            <dd>Returns a new copy of this Vec3.</dd>
            <dt>Vec3 cross(Vec3 other)</dt>
            <dd>Returns the cross product of this and the other vector as a new Vec3.</dd>
            <dt>float dist(Vec3 other)</dt>
            <dd>The distance between this and the given vector.</dd>
            <dt>Vec3 divide(Vec3 other)</dt>
            <dd>Returns the component wise division of the two vectors as a new Vec3.</dd>
            <dt>float dot(Vec3 other)</dt>
            <dd>The dot product of this and the given vector.</dd>
            <dt>float length()</dt>
            <dd>Returns the length of this vector.</dd>
            <dt>Vec3 lerp()</dt>
            <dd>Returns a linear interpolation between the two vectors as a new Vec3.
                <dl class='parameters'>
                    <dt>Vec3 other</dt>
                    <dd></dd>
                    <dt>float weight</dt>
                    <dd>Interpolation amount between the two vectors, range of [0,1].</dd>
                </dl>
            </dd>
            <dt>Vec3 max(Vec3 other)</dt>
            <dd>Returns a new Vec3 that contains the component wise maximum of the two vectors.</dd>
            <dt>Vec3 min(Vec3 other)</dt>
            <dd>Returns a new Vec3 that contains the component wise minimum of the two vectors.</dd>
            <dt>Vec3 mul(Vec3 other)</dt>
            <dd>Returns the component wise multiplication of the two vectors as a new Vec3.
            <dt>Vec3 mul(Mat3 other)</dt>
            <dd>Returns the transformation of this vector with the given 3x3 matrix as a new Vec3.</dd>
            <dt>Vec3 mul(Mat4 other)</dt>
            <dd>Returns the transformation of this vector with the given 4x4 matrix as a new Vec3. The fourth vector
                component is implicitly '1'
            </dd>
            <dt>Vec3 mul(Quat q)</dt>
            <dd>Returns the transformation of this vector with the given quaternion as a new Vec3.</dd>

            <dt>Vec3 negate()</dt>
            <dd>Returns the component wise negation of this vector as a new Vec3.</dd>
            <dt>Vec3 normalize()</dt>
            <dd>Returns the normalized representation of this vector as a new Vec3.</dd>
            <dt>static Vec3 random(optional float scale)</dt>
            <dd>Generates a random vector with the given scale, or a unit vector if omitted.</dd>
            <dt>Vec3 reciprocal()</dt>
            <dd>Returns the component wise reciprocal of this vector as a new Vec3.</dd>
            <dt>Vec3 scale(float scale)</dt>
            <dd>Returns the scaled vector as a new Vec3.</dd>
            <dt>Vec3 sub(Vec3 other)</dt>
            <dd>Returns the component wise subtraction of the two vectors as a new Vec3.</dd>

            <dt>Vec3 transformDirection(Mat4 mat)</dt>
            <dd>Returns the transformation of this vector with the given 4x4 matrix as a new Vec3. The fourth vector
                component is implicitly '0'
            </dd>

            <dt>static Vec3 wrap(Float32Array data)</dt>
            <dd>Returns a new Vec3 wrapper around the given Float32Array. Note: Changes to the returned Vec3 will also
                change the data in the array!
            </dd>
        </dl>
    </section>
    <section>
        <h3>Vec4</h3>
        <dl class='element'>
        </dl>
        <p>A four component vector object.</p>

        <dl title='interface Vec4' class='idl' id="idl-def-Vec4">
            <dt>attribute Float32Array data</dt>
            <dd>The underlying typed array that this Vec4 wraps.</dd>
            <dt>attribute float x</dt>
            <dd>Provides mutable access to the first component of this vector.</dd>
            <dt>attribute float y</dt>
            <dd>Provides mutable access to the second component of this vector.</dd>
            <dt>attribute float z</dt>
            <dd>Provides mutable access to the third component of this vector.</dd>
            <dt>attribute float w</dt>
            <dd>Provides mutable access to the fourth component of this vector.</dd>
            <dt>static Vec4 fromDOMString(DOMString str)</dt>
            <dd>Creates a new Vec4 object from the space-separated string representation as used in XML3D element
                attributes.
            </dd>
            <dt>DOMString toDOMString(Vec4 vec)</dt>
            <dd>Converts a Vec4 into the space-seperated string representation used in XML3D element attributes.</dd>

            <dt>Constructor ()</dt>
            <dd>Creates a new identity Vec4 <code>[0,0,0,0]</code></dd>
            <dt>Constructor (float x, float y, float z, float w)</dt>
            <dd>Creates a new Vec4 from the given values.</dd>
            <dt>Constructor (Float32Array other)</dt>
            <dd>Creates a new Vec4 which is a copy of the values in the passed array.</dd>
            <dt>Constructor (Vec4 other)</dt>
            <dd>Creates a new Vec4 which is a copy of the given Vec4.</dd>

            <dt>Vec4 add(Vec4 other)</dt>
            <dd>Returns the component wise addition of the two vectors as a new Vec4.</dd>
            <dt>Vec4 clone()</dt>
            <dd>Returns a new copy of this Vec4.</dd>
            <dt>float dist(Vec4 other)</dt>
            <dd>The distance between this and the given vector.</dd>
            <dt>Vec4 divide(Vec4 other)</dt>
            <dd>Returns the component wise division of the two vectors as a new Vec4.</dd>
            <dt>float dot(Vec4 other)</dt>
            <dd>The dot product of this and the given vector.</dd>
            <dt>float length()</dt>
            <dd>Returns the length of this vector.</dd>
            <dt>Vec4 lerp()</dt>
            <dd>Returns a linear interpolation between the two vectors as a new Vec4.
                <dl class='parameters'>
                    <dt>Vec4 other</dt>
                    <dd></dd>
                    <dt>float weight</dt>
                    <dd>Interpolation amount between the two vectors, range of [0,1].</dd>
                </dl>
            </dd>
            <dt>Vec4 max(Vec4 other)</dt>
            <dd>Returns a new Vec4 that contains the component wise maximum of the two vectors.</dd>
            <dt>Vec4 min(Vec4 other)</dt>
            <dd>Returns a new Vec4 that contains the component wise minimum of the two vectors.</dd>
            <dt>Vec4 mul(Vec4 other)</dt>
            <dd>Returns the component wise multiplication of the two vectors as a new Vec4.</dd>
            <dt>Vec4 mul(Mat4 other)</dt>
            <dd>Returns the transformation of this vector with the given 4x4 matrix as a new Vec4.</dd>
            <dt>Vec4 negate()</dt>
            <dd>Returns the component wise negation of this vector as a new Vec4.</dd>
            <dt>Vec4 normalize()</dt>
            <dd>Returns the normalized representation of this vector as a new Vec4.</dd>
            <dt>static Vec4 random(optional float scale)</dt>
            <dd>Generates a random vector with the given scale, or a unit vector if omitted.</dd>
            <dt>Vec4 scale(float scale)</dt>
            <dd>Returns the scaled vector as a new Vec4.</dd>
            <dt>Vec4 sub(Vec4 other)</dt>
            <dd>Returns the component wise subtraction of the two vectors as a new Vec4.</dd>

            <dt>Vec4 transformQuat(Quat q)</dt>
            <dd>Returns the transformation of this vector with the given quaternion as a new Vec4.</dd>
            <dt>static Vec4 wrap(Float32Array data)</dt>
            <dd>Returns a new Vec4 wrapper around the given Float32Array. Note: Changes to the returned Vec4 will also
                change the data in the array!
            </dd>
        </dl>
    </section>
    <section>
        <h3>AxisAngle</h3>
        <dl class='element'>
        </dl>
        <p>An axis-angle representation of a rotation with the angle in radians. This type is used for all XML3D
            interface methods and element attributes that expect a rotation.
            When working with rotations mathematically it's best to first convert the AxisAngle representation to a Quat
            and convert back to AxisAngle when
            passing the result back to an XML3D interface.</p>

        <dl title='interface AxisAngle' class='idl'>
            <dt>attribute Float32Array data</dt>
            <dd>The underlying typed array that this AxisAngle wraps in the form <code>[x, y, z, angle]</code></dd>
            <dt>attribute Vec3 axis</dt>
            <dd>Provides mutable access to the axis vector.</dd>
            <dt>attribute float angle</dt>
            <dd>Provides mutable access to the angle component. The angle should always be in radians.</dd>
            <dt>static AxisAngle fromDOMString(DOMString str)</dt>
            <dd>Creates a new AxisAngle object from the space-separated string representation as used in XML3D element
                attributes.
            </dd>
            <dt>DOMString toDOMString(AxisAngle vec)</dt>
            <dd>Converts a AxisAngle into the space-seperated string representation used in XML3D element attributes.
            </dd>

            <dt>Constructor ()</dt>
            <dd>Creates a new identity AxisAngle <code>[0,0,1,0]</code></dd>
            <dt>Constructor (float x, float y, float z, float angle)</dt>
            <dd>Creates a new AxisAngle from the given values.</dd>
            <dt>Constructor (Float32Array other)</dt>
            <dd>Creates a new AxisAngle which is a copy of the values in the passed array.</dd>
            <dt>Constructor (AxisAngle other)</dt>
            <dd>Creates a new AxisAngle which is a copy of the given AxisAngle.</dd>

            <dt>AxisAngle clone()</dt>
            <dd>Returns a new copy of this AxisAngle.</dd>
            <dt>static AxisAngle fromQuat(Quat q)</dt>
            <dd>Creates a new axis-angle representation of the given quaternion's rotation.</dd>
            <dt>Quat toQuat()</dt>
            <dd>Creates a new quaternion representation of this AxisAngle's rotation.</dd>
            <dt>static AxisAngle wrap(Float32Array data)</dt>
            <dd>Returns a new AxisAngle wrapper around the given Float32Array. Note: Changes to the returned AxisAngle
                will also change the data in the array!
            </dd>
        </dl>
    </section>

    <section>
        <h3>Quat</h3>
        <dl class='element'>
        </dl>
        <p>Quat represents a rotation as a quaternion of the form [x, y, z, w]. The provided functions and accessors
            do not automatically normalize the quaternion unless otherwise stated.</p>

        <dl title='interface Quat' class='idl'>
            <dt>attribute Float32Array data</dt>
            <dd>The underlying typed array that this Quat wraps.</dd>
            <dt>attribute float x</dt>
            <dd>Provides mutable access to the first component of this quaternion.</dd>
            <dt>attribute float y</dt>
            <dd>Provides mutable access to the second component of this quaternion.</dd>
            <dt>attribute float z</dt>
            <dd>Provides mutable access to the third component of this quaternion.</dd>
            <dt>attribute float w</dt>
            <dd>Provides mutable access to the fourth component of this quaternion.</dd>
            <dt>static Quat fromDOMString(DOMString str)</dt>
            <dd>Creates a new Quat object from a space-separated string representation.</dd>
            <dt>DOMString toDOMString(Quat vec)</dt>
            <dd>Converts a Quat into a space-seperated string representation.</dd>

            <dt>Constructor ()</dt>
            <dd>Creates a new identity Quat <code>[0,0,0,1]</code></dd>
            <dt>Constructor (float x, float y, float z, float w)</dt>
            <dd>Creates a new Quat from the given values.</dd>
            <dt>Constructor (Float32Array other)</dt>
            <dd>Creates a new Quat which is a copy of the values in the passed array.</dd>
            <dt>Constructor (Quat other)</dt>
            <dd>Creates a new Quat which is a copy of the given Quat.</dd>

            <dt>Quat add(Quat other)</dt>
            <dd>Returns the addition of the two quaternions as a new Quat.</dd>
            <dt>Quat clone()</dt>
            <dd>Returns a new copy of this Quat.</dd>
            <dt>Quat calculateW()</dt>
            <dd>Returns a new Quat with the w component calculated from the x,y,z components of this quaternion. Any
                existing w component will be ignored.
            </dd>
            <dt>Quat conjugate()</dt>
            <dd>Returns the conjugate of this quaternion as a new Quat. Note: This method should only be used on
                normalized quaternions!
            </dd>
            <dt>float dot(Quat other)</dt>
            <dd>Returns the dot product of the two quaternions.</dd>
            <dt>Quat invert()</dt>
            <dd>Returns the inverse of this quaternion as a new Quat. This is slower than <code>Quat.conjugate</code>
                but also works on non-normalized quaternions.
            </dd>
            <dt>float length()</dt>
            <dd>Returns the magnitude of this quaternion.</dd>
            <dt>Quat lerp()</dt>
            <dd>Returns a linear interpolation between the two quaternions as a new Quat.
                <dl class='parameters'>
                    <dt>Quat other</dt>
                    <dd></dd>
                    <dt>float weight</dt>
                    <dd>Interpolation amount between the two quaternions, range of [0,1].</dd>
                </dl>
            </dd>
            <dt>Quat mul(Quat other)</dt>
            <dd>Returns the component wise multiplication of the two quaternions as a new Quat.</dd>
            <dt>Quat normalize()</dt>
            <dd>Returns the normalized representation of this quaternion as a new Quat.</dd>
            <dt>Quat rotateX(float angleInRadians)</dt>
            <dd>Returns a new quaternion representing this one rotated around the X axis by the given angle.</dd>
            <dt>Quat rotateY(float angleInRadians)</dt>
            <dd>Returns a new quaternion representing this one rotated around the Y axis by the given angle.</dd>
            <dt>Quat rotateZ(float angleInRadians)</dt>
            <dd>Returns a new quaternion representing this one rotated around the Z axis by the given angle.</dd>
            <dt>Quat scale(float scale)</dt>
            <dd>Returns the scaled quaternion as a new Quat. This is identical to <a>Vec4</a>.scale.</dd>
            <dt>static Quat fromAxisAngle(AxisAngle a)</dt>
            <dd>Generates a normalized quaternion representation of the given AxisAngle.</dd>
            <dt>static Quat fromBasis(Vec3 x, Vec3 y, Vec3 z)</dt>
            <dd>Generates a normalized quaternion from the given basis vectors, defined as the rotation between the coordinate
                space defined by these vectors and the standard space.
            </dd>
            <dt>static Quat fromMat3(Mat3 mat)</dt>
            <dd>Generates a normalized quaternion from the given rotation matrix.</dd>
            <dt>static Quat fromRotationTo(Vec3 from, Vec3 to)</dt>
            <dd>Generates a normalized quaternion representing the shortest rotation from one vector to another.</dd>
            <dt>Quat slerp()</dt>
            <dd>Returns a spherical linear interpolation between the two quaternions as a new Quat.
                <dl class='parameters'>
                    <dt>Quat other</dt>
                    <dd></dd>
                    <dt>float weight</dt>
                    <dd>Interpolation amount between the two quaternions, range of [0,1].</dd>
                </dl>
            </dd>
            <dt>static Quat wrap(Float32Array data)</dt>
            <dd>Returns a new Quat wrapper around the given Float32Array. Note: Changes to the returned Quat will also
                change the data in the array!
            </dd>
        </dl>
    </section>

    <section>
        <h3>Mat2</h3>
        <dl class='element'>
        </dl>
        <p>A 2x2 matrix object.</p>

        <dl title='interface Mat2' class='idl' id="idl-def-Mat2">
            <dt>attribute Float32Array data</dt>
            <dd>The underlying typed array that this Mat2 wraps.</dd>
            <dt>attribute float m11</dt>
            <dd>Provides mutable access to the first column of the first row of this matrix.</dd>
            <dt>attribute float m12</dt>
            <dd>Provides mutable access to the second column of the first row of this matrix.</dd>
            <dt>attribute float m21</dt>
            <dd>Provides mutable access to the first column of the second row of this matrix.</dd>
            <dt>attribute float m22</dt>
            <dd>Provides mutable access to the second column of the second row of this matrix.</dd>

            <dt>Constructor ()</dt>
            <dd>Creates a new identity Mat2.</dd>
            <dt>Constructor (Float32Array other)</dt>
            <dd>Creates a new Mat2 which is a copy of the values in the passed array.</dd>
            <dt>Constructor (Mat2 other)</dt>
            <dd>Creates a new Mat2 which is a copy of the given Mat2.</dd>

            <dt>Mat2 adjoint()</dt>
            <dd>Computes the adjugate of this matrix as a new Mat2.</dd>
            <dt>Mat2 clone()</dt>
            <dd>Returns a new copy of this Mat2.</dd>
            <dt>float determinant()</dt>
            <dd>Computes the determinant of this matrix.</dd>
            <dt>Mat2 invert()</dt>
            <dd>Returns the inverse of this matrix as a new Mat2. If this matrix is not invertible <code>null</code>
                will be returned.
            </dd>

            <dt>Mat2 mul(Mat2 other)</dt>
            <dd>Returns the multiplication of this matrix with the other as a new Mat2.</dd>
            <dt>Mat2 rotate(float angleInRadians)</dt>
            <dd>Returns the rotation of this matrix by the given angle in radians as a new Mat2.</dd>
            <dt>Mat2 scale(Vec2 scale)</dt>
            <dd>Returns the scaled matrix as a new Mat2.</dd>
            <dt>Mat2 transpose()</dt>
            <dd>Returns the transpose of this matrix as a new Mat2.</dd>
            <dt>static Mat2 wrap(Float32Array data)</dt>
            <dd>Returns a new Mat2 wrapper around the given Float32Array. Note: Changes to the returned Mat2 will also
                change the data in the array!
            </dd>
        </dl>
    </section>
    <section>
        <h3>Mat3</h3>
        <dl class='element'>
        </dl>
        <p>A 3x3 matrix object.</p>

        <dl title='interface Mat3' class='idl' id="idl-def-Mat3">
            <dt>attribute Float32Array data</dt>
            <dd>The underlying typed array that this Mat3 wraps.</dd>
            <dt>attribute float m11</dt>
            <dd>Provides mutable access to the first column of the first row of this matrix.</dd>
            <dt>attribute float m12</dt>
            <dd>Provides mutable access to the second column of the first row of this matrix.</dd>
            <dt>attribute float m13</dt>
            <dd>Provides mutable access to the third column of the first row of this matrix.</dd>
            <dt>attribute float m21</dt>
            <dd>Provides mutable access to the first column of the second row of this matrix.</dd>
            <dt>attribute float m22</dt>
            <dd>Provides mutable access to the second column of the second row of this matrix.</dd>
            <dt>attribute float m23</dt>
            <dd>Provides mutable access to the third column of the second row of this matrix.</dd>
            <dt>attribute float m31</dt>
            <dd>Provides mutable access to the first column of the third row of this matrix.</dd>
            <dt>attribute float m32</dt>
            <dd>Provides mutable access to the second column of the third row of this matrix.</dd>
            <dt>attribute float m33</dt>
            <dd>Provides mutable access to the third column of the third row of this matrix.</dd>

            <dt>Constructor ()</dt>
            <dd>Creates a new identity Mat3.</dd>
            <dt>Constructor (Float32Array other)</dt>
            <dd>Creates a new Mat3 which is a copy of the values in the passed array.</dd>
            <dt>Constructor (Mat3 other)</dt>
            <dd>Creates a new Mat3 which is a copy of the given Mat3.</dd>

            <dt>Mat3 adjoint()</dt>
            <dd>Computes the adjugate of this matrix as a new Mat3.</dd>
            <dt>Mat3 clone()</dt>
            <dd>Returns a new copy of this Mat3.</dd>
            <dt>float determinant()</dt>
            <dd>Computes the determinant of this matrix.</dd>
            <dt>static Mat3 fromMat4(Mat4 mat)</dt>
            <dd>Creates a new Mat3 from the upper-left values of the given 4x4 matrix.</dd>
            <dt>static Mat3 fromQuat(Quat q)</dt>
            <dd>Creates a new 3x3 rotation matrix from the given quaternion.</dd>
            <dt>static Mat3 normalFromMat4(Mat4 mat)</dt>
            <dd>Creates a 3x3 normal matrix (transpose inverse) from the given 4x4 matrix.</dd>
            <dt>Mat3 invert()</dt>
            <dd>Returns the inverse of this matrix as a new Mat3. If this matrix is not invertible <code>null</code>
                will be returned.
            </dd>
            <dt>Mat3 mul(Mat3 other)</dt>
            <dd>Returns the multiplication of this matrix with the other as a new Mat3.</dd>
            <dt>Mat3 rotate(float angleInRadians)</dt>
            <dd>Returns the rotation of this matrix by the given angle in radians as a new Mat3.</dd>
            <dt>Mat3 scale(Vec3 scale)</dt>
            <dd>Returns the scaled matrix as a new Mat3.</dd>
            <dt>Mat3 translate(Vec3 translation)</dt>
            <dd>Returns the translated matrix as a new Mat3.</dd>
            <dt>Mat3 transpose()</dt>
            <dd>Returns the transpose of this matrix as a new Mat3.</dd>
            <dt>static Mat3 wrap(Float32Array data)</dt>
            <dd>Returns a new Mat3 wrapper around the given Float32Array. Note: Changes to the returned Mat3 will also
                change the data in the array!
            </dd>
        </dl>
    </section>

    <section>
        <h3>Mat4</h3>
        <dl class='element'>
        </dl>
        <p>A 4x4 matrix object.</p>

        <dl title='interface Mat4' class='idl' id="idl-def-Mat4">
            <dt>attribute Float32Array data</dt>
            <dd>The underlying typed array that this Mat4 wraps.</dd>
            <dt>attribute float m11</dt>
            <dd>Provides mutable access to the first column of the first row of this matrix.</dd>
            <dt>attribute float m12</dt>
            <dd>Provides mutable access to the second column of the first row of this matrix.</dd>
            <dt>attribute float m13</dt>
            <dd>Provides mutable access to the third column of the first row of this matrix.</dd>
            <dt>attribute float m14</dt>
            <dd>Provides mutable access to the fourth column of the first row of this matrix.</dd>
            <dt>attribute float m21</dt>
            <dd>Provides mutable access to the first column of the second row of this matrix.</dd>
            <dt>attribute float m22</dt>
            <dd>Provides mutable access to the second column of the second row of this matrix.</dd>
            <dt>attribute float m23</dt>
            <dd>Provides mutable access to the third column of the second row of this matrix.</dd>
            <dt>attribute float m24</dt>
            <dd>Provides mutable access to the fourth column of the second row of this matrix.</dd>
            <dt>attribute float m31</dt>
            <dd>Provides mutable access to the first column of the third row of this matrix.</dd>
            <dt>attribute float m32</dt>
            <dd>Provides mutable access to the second column of the third row of this matrix.</dd>
            <dt>attribute float m33</dt>
            <dd>Provides mutable access to the third column of the third row of this matrix.</dd>
            <dt>attribute float m34</dt>
            <dd>Provides mutable access to the fourth column of the third row of this matrix.</dd>
            <dt>attribute float m41</dt>
            <dd>Provides mutable access to the first column of the fourth row of this matrix.</dd>
            <dt>attribute float m42</dt>
            <dd>Provides mutable access to the second column of the fourth row of this matrix.</dd>
            <dt>attribute float m43</dt>
            <dd>Provides mutable access to the third column of the fourth row of this matrix.</dd>
            <dt>attribute float m44</dt>
            <dd>Provides mutable access to the fourth column of the fourth row of this matrix.</dd>

            <dt>Constructor ()</dt>
            <dd>Creates a new identity Mat4.</dd>
            <dt>Constructor (Float32Array other)</dt>
            <dd>Creates a new Mat4 which is a copy of the values in the passed array.</dd>
            <dt>Constructor (Mat4 other)</dt>
            <dd>Creates a new Mat4 which is a copy of the given Mat4.</dd>

            <dt>Mat4 adjoint()</dt>
            <dd>Computes the adjugate of this matrix as a new Mat4.</dd>
            <dt>Mat4 clone()</dt>
            <dd>Returns a new copy of this Mat4.</dd>
            <dt>float determinant()</dt>
            <dd>Computes the determinant of this matrix.</dd>
            <dt>static Mat4 frustum(float left, float right, float bottom, float top, float near, float far)</dt>
            <dd>Generates a frustum matrix with the given bounds.</dd>
            <dt>Mat4 invert()</dt>
            <dd>Returns the inverse of this matrix as a new Mat4. If this matrix is not invertible <code>null</code>
                will be returned.
            </dd>
            <dt>static Mat4 lookAt(Vec3 eye, Vec3 center, Vec3 up)</dt>
            <dd>Generates a look-at matrix with the given eye position, focal point and up axis.</dd>
            <dt>Mat4 mul(Mat4 other)</dt>
            <dd>Returns the multiplication of this matrix with the other as a new Mat4.</dd>
            <dt>static Mat4 ortho(float left, float right, float bottom, float top, float near, float far)</dt>
            <dd>Generates an orthogonal projection matrix with the given bounds.</dd>
            <dt>static Mat4 perspective(float left, float right, float bottom, float top, float near, float far)</dt>
            <dd>Generates a perspective projection matrix with the given bounds.</dd>
            <dt>Mat4 rotate(float angleInRadians, Vec3 axis)</dt>
            <dd>Returns the rotation of this matrix by the given angle around the given axis as a new Mat4.</dd>
            <dt>Mat4 rotateX(float angleInRadians)</dt>
            <dd>Returns the rotation of this matrix by the given angle around the X axis as a new Mat4.</dd>
            <dt>Mat4 rotateY(float angleInRadians)</dt>
            <dd>Returns the rotation of this matrix by the given angle around the Y axis as a new Mat4.</dd>
            <dt>Mat4 rotateZ(float angleInRadians)</dt>
            <dd>Returns the rotation of this matrix by the given angle around the Z axis as a new Mat4.</dd>
            <dt>Mat4 scale(Vec3 scale)</dt>
            <dd>Returns the scaled matrix as a new Mat4.</dd>
            <dt>Mat4 translate(Vec3 translation)</dt>
            <dd>Returns the translated matrix as a new Mat4.</dd>
            <dt>Mat4 transpose()</dt>
            <dd>Returns the transpose of this matrix as a new Mat4.</dd>
            <dt>static Mat4 fromQuat(Quat q)</dt>
            <dd>Generates a 4x4 rotation matrix from the given quaternion.</dd>
            <dt>static Mat4 fromRotationTranslation(Quat rotation, Vec3 translation)</dt>
            <dd>Generates a matrix representing the given rotation and translation. This is much faster than setting the
                transformations individually.
            </dd>
            <dt>static Mat4 wrap(Float32Array data)</dt>
            <dd>Returns a new Mat4 wrapper around the given Float32Array. Note: Changes to the returned Mat4 will also
                change the data in the array!
            </dd>
        </dl>
    </section>

    <section>
        <h3>Box</h3>
        <dl class='element'>
        </dl>
        <p>The Box type represents a bounding box with a stored minimum and maximum point. Unlike the math types the
            methods of the Box object are mutable and, when applicable,
            return the same instance of the Box.</p>

        <dl title='interface Box' class='idl'>
            <dt>attribute Float32Array data</dt>
            <dd>The underlying typed array that this Box wraps.</dd>
            <dt>attribute Vec3 min</dt>
            <dd>Mutable accessor to the minimum point of this bounding box.</dd>
            <dt>attribute Vec3 max</dt>
            <dd>Mutable accessor to the maximum point of this bounding box.</dd>

            <dt>Constructor ()</dt>
            <dd>Creates a new empty Box with <code>min</code> set to <code>MAX_VALUE</code> and <code>max</code> set to
                <code>MIN_VALUE</code>.
            </dd>
            <dt>Constructor (Box other)</dt>
            <dd>Creates a new Box which is a copy of the given Box.</dd>

            <dt>Box clone()</dt>
            <dd>Returns a new clone of this bounding box.</dd>
            <dt>Box copy(Box other)</dt>
            <dd>Copies the minimum and maximum points from the other bounding box into this one.</dd>

            <dt>Box copyMin(Box other)</dt>
            <dd>Copies only the minimum point from the given Box.</dd>
            <dt>Box copyMax(Box other)</dt>
            <dd>Copies only the maximum point from the given Box.</dd>
            <dt>Box extend(Box other)</dt>
            <dd>Expands this box to also enclose the given box. This method respects axis alignment if both boxes are
                axis aligned.
            </dd>
            <dt>Box setEmpty()</dt>
            <dd>Resets this box to the empty state.</dd>
            <dt>boolean isEmpty()</dt>
            <dd>Returns true if the box is empty. Empty is defined as any box whose minimum point is greater than its
                maximum.
            </dd>
            <dt>Vec3 center()</dt>
            <dd>Returns the center of this box as a new Vec3.</dd>
            <dt>Vec3 size()</dt>
            <dd>Returns the size of this box as a new Vec3.</dd>
            <dt>Vec3 extent()</dt>
            <dd>Returns the extent of this box as a new Vec3, defined as half of its size.</dd>
            <dt>Box transformAxisAligned(Mat4 mat)</dt>
            <dd>Transforms this box with the given transformation matrix. This box will remain axis-aligned.</dd>
            <dt>Box transform(Mat4 mat)</dt>
            <dd>Transforms this box with the given transformation matrix. This method does not enforce axis
                alignment./dd>
            <dt>float longestSide()</dt>
            <dd>Returns the length of the longest side of this box.</dd>
            <dt>boolean intersects()</dt>
            <dd>
                <dl class='parameters'>
                    <dt>Ray r</dt>
                    <dd></dd>
                    <dt>optional Object opt</dt>
                    <dd>If <code>opt.dist</code> exists then the distance to the intersection point will be written into
                        this field. If the ray does
                        not intersect then this field will hold <code>Infinity</code></dd>
                </dl>

                Returns true if the given ray intersects this box.
            </dd>
            <dt>boolean contains(Vec3 point)</dt>
            <dd>Returns true if the given point is inside the box.</dd>
            <dt>DOMString toString()</dt>
            <dd>A human readable string representation of this box.</dd>
        </dl>
    </section>
    <section>
        <h3>Ray</h3>
        <dl class='element'>
        </dl>
        <p>The Ray type represents a ray with an origin and a direction. Unlike the math types Rays are mutable and
            methods will return the same instance, if applicable.</p>

        <dl title='interface Ray' class='idl'>
            <dt>attribute Float32Array data</dt>
            <dd>The underlying typed array that this Ray wraps.</dd>
            <dt>attribute Vec3 origin</dt>
            <dd>Mutable accessor to the origin point of this ray.</dd>
            <dt>attribute Vec3 direction</dt>
            <dd>Mutable accessor to the direction of this ray. Assignments should always be normalized.</dd>

            <dt>Constructor ()</dt>
            <dd>Creates a new Ray with origin <code>[0,0,0]</code> and direction <code>[0,0,-1]</code></dd>
            <dt>Constructor (Ray other)</dt>
            <dd>Creates a new Ray which is a copy of the given Ray.</dd>

            <dt>Ray clone()</dt>
            <dd>Returns a new clone of this ray.</dd>
            <dt>Ray copy(Ray other)</dt>
            <dd>Copies the origin and direction from the other ray into this one.</dd>

            <dt>Ray copyOrigin(Ray other)</dt>
            <dd>Copies only the origin from the given Ray.</dd>
            <dt>Ray copyMax(Ray other)</dt>
            <dd>Copies only the direction from the given Ray.</dd>
            <dt>Box setFromOriginDirection(Vec3 origin, Vec3 direction)</dt>
            <dd>Sets the origin and direction of this ray to the given values.</dd>
            <dt>boolean intersects()</dt>
            <dd>
                <dl class='parameters'>
                    <dt>Box box</dt>
                    <dd></dd>
                    <dt>optional Object opt</dt>
                    <dd>If <code>opt.dist</code> exists then the distance to the intersection point will be written into
                        this field. If the ray does
                        not intersect then this field will hold <code>Infinity</code></dd>
                </dl>

                Returns true if this ray intersects the given box.
            </dd>
            <dt>DOMString toString()</dt>
            <dd>A human readable string representation of this ray.</dd>
        </dl>
    </section>
</section>

<section>
    <h2>Events</h2>
    <section>
        <h3>Mouse and Keyboard Events</h3>
        The following event listeners are available on all <a href="#pickable-elements">pickable elements</a> as well as
        the <a>group element</a> and the <a>xml3d element</a>:
        <ul>
            <li>onclick</li>
            <li>ondblclick</li>
            <li>onmousedown</li>
            <li>onmouseup</li>
            <li>onmouseover</li>
            <li>onmousemove</li>
            <li>onmouseout</li>
            <li>onkeypress</li>
            <li>onkeydown</li>
            <li>onkeyup</li>
        </ul>
        The event received by these listeners is a standard HTML5 <a
            href="http://www.w3.org/TR/DOM-Level-3-Events/#events-mouseevents">MouseEvent</a>
        or <a href="http://www.w3.org/TR/DOM-Level-3-Events/#events-keyboardevents">KeyboardEvent</a> respectively. As
        in normal HTML, event listeners
        may be added to the element through an appropriate <code>on[eventName]</code> attribute or through JavaScript
        using <code>element.addEventListener(...)</code>.
        <div class="note">Listeners registered through an attribute must use the following format: <code>"myListenerFunction(event)"</code>
        </div>
    </section>
    <section>
        <h3>FrameDrawn</h3>
        <dl title='interface FrameDrawn : CustomEvent' class='idl'>
            <dt>attribute float detail.timeStart</dt>
            <dd>The system time at the beginning of the frame draw.</dd>
            <dt>attribute float detail.timeEnd</dt>
            <dd>The system time at the end of the frame draw.</dd>
            <dt>attribute float detail.renderTimeInMilliseconds</dt>
            <dd>The total time taken to render this frame. Includes time spent updating the scene state and any XFlow
                data processing.
            </dd>
            <dt>attribute int detail.count.objects</dt>
            <dd>The total number of distinct meshes drawn in this frame after applying frustum culling (if enabled).
            </dd>
            <dt>attribute int detail.count.primitives</dt>
            <dd>The total number of primitives drawn in this frame after applying frustum culling (if enabled).</dd>
        </dl>
    </section>
</section>

</body>
</html>
