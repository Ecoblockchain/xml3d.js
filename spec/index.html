<!DOCTYPE html>
<html>
<head lang="en">
  <meta charset="UTF-8">
  <title>XML3D 5.0 Specification</title>
  <script src='http://www.w3.org/Tools/respec/respec-w3c-common' async class='remove'></script>
  <link rel="stylesheet" href="xml3d-spec.css">

  <script class='remove'>
    var respecConfig = {
      // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
      specStatus: "unofficial",

      // the specification's short name, as in http://www.w3.org/TR/short-name/
      shortName: "xml3d",

      // if your specification has a subtitle that goes below the main
      // formal title, define it here
      subtitle: "Interactive 3D Graphics for the Web",

      // if you wish the publication date to be other than today, set this
      publishDate:  "",

      // if the specification's copyright date is a range of years, specify
      // the start date here:
      // copyrightStart: "2005",

      // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
      // and its maturity status
      // previousPublishDate:  "1977-03-15",
      // previousMaturity:  "WD",

      // if there a publicly available Editor's Draft, this is the link
      // edDraftURI: "http://dev.w3.org/2009/dap/ReSpec.js/documentation.html",
      previousURI: "http://www.xml3d.org/xml3d/specification/0.4.3/",

      // editors, add as many as you like
      // only "name" is required
      editors: [{
        name: "Kristian Sons"
      }, {
        name: "Christian Schlinkmann"
      }],

      // authors, add as many as you like.
      // This is optional, uncomment if you have authors as well as editors.
      // only "name" is required. Same format as editors.

      authors: [{
        name: "Felix Klein",
        company: "Intel Visual Computing Institute",
        companyURL: "http://www.intel-vci.uni-saarland.de/"
      }, {
        name: "Kristian Sons", company: "DFKI", companyURL: "http://www.dfki.de/"
      }, {
        name: "Christian Schlinkmann", company: "DFKI", companyURL: "http://www.dfki.de/"}
      ],

      // name of the WG
      wg: "Declarative 3D Community Group",

      // URI of the public WG page
      wgURI: "http://www.w3.org/community/declarative3d/",

      // name (without the @w3c.org) of the public mailing to which comments are due
      wgPublicList: "public-declarative3d",

      // URI of the patent status for this WG, for Rec-track documents
      // !!!! IMPORTANT !!!!
      // This is important for Rec-track documents, do not copy a patent URI from a random
      // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
      // Team Contact.
      wgPatentURI: "http://www.w3.org/community/about/agreements/cla/"
    };
  </script>
</head>
<body>
<section id='abstract'>
</section>

<section>
  <h2>Introduction</h2>
</section>

<section>
  <h2>Concepts</h2>
  <section>
    <h3>Generic data model</h3>
  </section>
</section>

<section>
  <h2>Predefined models</h2>
  <section>
    <h3>Predefined primitive types</h3>
    <section>
      <h2>Triangle</h2>
      <p>Attribute name: <code>triangles</code></p>
      <p>WebGL primitive: <code>TRIANGLE</code></p>

      <p>The triangle primitive type renders faces out of sets of 3 vertices. Triangles may be constructed with or without an array of indices. If no indices are provided
        XML3D will construct the triangles from the array of vertex positions: the first 3 will create the first triangle, the next 3 the second and so on.</p>

      <pre class="example highlight">
        &lt;mesh type="triangles"&gt;
          &lt;int name="index"&gt;0 1 2 1 3 2 ... &lt;/int&gt;
          &lt;float3 name="position"&gt;-1 -1 1  1 -1 1  -1 1 1  1 1 1 ... &lt;/float3&gt;
        &lt;/mesh&gt;
      </pre>

    </section>

    <section>
      <h2>Tristrip</h2>
      <p>Attribute name: <code>tristrips</code></p>
      <p>WebGL primitive: <code>TRIANGLE_STRIP</code></p>

      <p>The tristrip primitive type creates triangles from a list of vertex positions and (optionally) a list of segments and/or indices. Each segment begins by building a triangle
        out of 3 vertex positions. Each subsequent triangle in the segment is then created from the last two vertex positions and the next one in the list. Note that this
        creates a sequence of connected triangles.</p>

      <p>Segments can be used to create disconnected sets of triangles by providing a list of integers with the name <code>vertexCount</code>. Each number in the list
        specifies the number of vertex positions to use for that segment. XML3D will then work through the list of vertex positions sequentially building a tristrip for each segment. </p>
      <div class="issue">Add parameter tables like in material models.</div>
      <pre class="example highlight">
        &lt;mesh type="tristrips"&gt;
          &lt;int name="vertexCount"&gt;4 4 4 4 4 4&lt;/int&gt;
          &lt;float3 name="position"&gt;-1 -1 1  1 -1 1  -1 1 1  1 1 1 ... &lt;/float3&gt;
        &lt;/mesh&gt;
      </pre>

      <p>Note that because the first triangle in a segment requires 3 vertex positions to define, a segment with vertex count 4 will create two triangles, while vertex
        count 5 will create 3 and so on.</p>
    </section>

    <section>
      <h2>Line</h2>
      <p>Attribute name: <code>lines</code></p>
      <p>WebGL primitive: <code>LINES</code></p>

      <p>Lines are drawn from pairs of vertex positions and (optionally) a list of indices. </p>
    </section>

    <section>
      <h2>Linestrip</h2>
      <p>Attribute name: <code>linestrips</code></p>
      <p>WebGL primitive: <code>LINE_STRIP</code></p>

      <p>A linestrip is drawn from a list of vertex positions and (optionally) a list of segments and/or indices. For each segment a line is drawn between the first vertex and
        the second, then the second and the third and so on. This creates a continuous line.</p>

      <pre class="example highlight">
      &lt;mesh type="linestrips"&gt;
        &lt;int name="vertexCount"&gt;4 2&lt;/int&gt;
        &lt;int name="index"&gt;0 1 2 3 1 3&lt;/int&gt;
        &lt;float3 name="position"&gt;-1 -1 1  1 -1 1  -1 1 1  1 1 1 ... &lt;/float3&gt;
      &lt;/mesh&gt;
      </pre>

      <p>The above example will create two line segments, the first using vertices 0, 1, 2, 3 and the second using vertices 1 and 3. </p>

    </section>

    <section>
      <h2>Point</h2>
      <p>Attribute name: <code>points</code></p>
      <p>WebGL primitive: <code>POINT</code></p>

      <p>Points are drawn from a list of vertex positions, which each position being drawn as a single point.</p>
      <div class="note">Currently to change the size of the drawn points, or to draw them as textured sprites, it is necessary to define a custom material shader.</div>
    </section>

  </section>
  <section>
    <h3>Predefined material models</h3>
    <section>
      <h2>Matte</h2>

      <p>URN: <code>urn:xml3d:material:matte</code></p>

      <div class="attributes">Attributes:
        <table>
          <tbody>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Default</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>diffuseColor</td>
            <td>float3</td>
            <td>1 1 1</td>
            <td>The objects RGB color</td>
          </tr>
          <tr>
            <td>useVertexColor</td>
            <td>bool</td>
            <td>false</td>
            <td>if true, the vertex attribute 'color' is used to color the object.</td>
          </tr>
          </tbody>
        </table>
      </div>
      <p>
        Simple material that does not apply any lighting but shades the object with a single uniform color defined by
        the <code>diffuseColor</code> parameter or by the
        vertex attribute <code>color</code>, if <code>useVertexColor</code> is set to ''true''.
      </p>
    </section>

    <section>
      <h2>Diffuse</h2>

      <p>URN: <code>urn:xml3d:material:diffuse</code></p>

      <div class="attributes">Attributes:
        <table>
          <tbody>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Default</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>diffuseColor</td>
            <td>float3</td>
            <td>1 1 1</td>
            <td>The object's RGB diffuse color component.</td>
          </tr>
          <tr>
            <td>diffuseTexture</td>
            <td>texture</td>
            <td>-</td>
            <td>TODO</td>
          </tr>

          <tr>
            <td>emissiveColor</td>
            <td>float3</td>
            <td>0 0 0</td>
            <td>The object's RGB emissive color component.</td>
          </tr>
          <tr>
            <td>emissiveTexture</td>
            <td>texture</td>
            <td>-</td>
            <td>TODO</td>
          </tr>
          <tr>
            <td>ambientIntensity</td>
            <td>float</td>
            <td>0</td>
            <td>The amount of the 'diffuseColor' to be added to the shading without considering lighting.</td>
          </tr>
          <tr>
            <td>transparency</td>
            <td>float</td>
            <td>0</td>
            <td>The transparency of the object, with 0 being opaque and 1 being fully transparent.</td>
          </tr>
          <tr>
            <td>useVertexColor</td>
            <td>bool</td>
            <td>false</td>
            <td>Setting <i>useVertexColor</i> to 'true', the vertex attribute 'color' will be multiplied to the diffuse
              color component.
            </td>
          </tr>
          </tbody>
        </table>
      </div>
      <p>
        Material model for diffuse surfaces that reflects light equally in all directions. Additionally, the surface has
        an optional emissive and ambient component.
        This is the logic of the diffuse material model in JavaScript/shade.js pseudo code:
      <pre class="highlight">
        function shade(env) {
          var diffuseColor = env.diffuseColor || new Vec3(1, 1, 1);
          var emissiveColor = env.emissiveColor || new Vec3(0);
          var transparency = Math.min(1, env.transparency);

          if (env.useVertexColor && env.color) {
            diffuseColor *= new Vec3(env.color);
          }

          if (env.diffuseTexture.sample2D) {
             var texDiffuse = env.diffuseTexture.sample2D(env.texcoord);
             diffuseColor *= texDiffuse.rgb();
             transparency *= (1 - texDiffuse.a());
          }

          return Shade.diffuse(diffuseColor, env.normal)
                      .transparent(transparency)
                      .emissive(emissiveColor);
        }
      </pre>
      </p>
    </section>

    <section>
      <h2>Phong</h2>

      <p>URN: <code>urn:xml3d:material:phong</code></p>

      <div class="attributes">Attributes:
        <table>
          <tbody>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Default</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>diffuseColor</td>
            <td>float3</td>
            <td>1 1 1</td>
            <td>The object's RGB diffuse color component.</td>
          </tr>
          <tr>
            <td>diffuseTexture</td>
            <td>texture</td>
            <td>-</td>
            <td>TODO</td>
          </tr>
          <tr>
            <td>specularColor</td>
            <td>float3</td>
            <td>0 0 0</td>
            <td>The object's RGB specular color component.</td>
          </tr>
          <tr>
            <td>specularTexture</td>
            <td>texture</td>
            <td>-</td>
            <td>TODO</td>
          </tr>
          <tr>
            <td>shininess</td>
            <td>float</td>
            <td>0.5</td>
            <td>A scalar for the object's specular exponent, to be multiplied by 128 (e.g. a value of 0.5 will give a specular exponent of 64)</td>
          </tr>
          <tr>
            <td>emissiveColor</td>
            <td>float3</td>
            <td>0 0 0</td>
            <td>The object's RGB emissive color component.</td>
          </tr>
          <tr>
            <td>emissiveTexture</td>
            <td>texture</td>
            <td>-</td>
            <td>TODO</td>
          </tr>
          <tr>
            <td>ambientIntensity</td>
            <td>float</td>
            <td>0</td>
            <td>The amount of the 'diffuseColor' to be added to the shading without considering lighting.</td>
          </tr>
          <tr>
            <td>transparency</td>
            <td>float</td>
            <td>0</td>
            <td>The transparency of the object, with 0 being opaque and 1 being fully transparent.</td>
          </tr>
          <tr>
            <td>useVertexColor</td>
            <td>bool</td>
            <td>false</td>
            <td>Setting <i>useVertexColor</i> to 'true', the vertex attribute 'color' will be multiplied to the diffuse
              color component.
            </td>
          </tr>
          </tbody>
        </table>
      </div>
      <p>
        TODO
      </p>
    </section>
  </section>

  <section>
    <h3>Predefined light models</h3>
    <section>
      <h2>Point Lights</h2>
      <p>URN: <code>urn:xml3d:light:point</code></p>
      <div class="attributes">Attributes:
        <table>
          <tbody><tr>
            <th>Name</th>
            <th>Type</th>
            <th>Default</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>position</td>
            <td>float3</td>
            <td>0 0 0</td>
            <td>The position of the point light in object space</td>
          </tr>
          <tr>
            <td>attenuation</td>
            <td>float3</td>
            <td>0 0 1</td>
            <td>The attenuation of the point light given as its constant, linear, e.g quadratic component.</td>
          </tr>
          <tr>
            <td>intensity</td>
            <td>float3</td>
            <td>1 1 1</td>
            <td>The RGB intensity of the point light.</td>
          </tr>
          </tbody>
        </table>
      </div>
      <p>
        Point light sources emit light from a single point in space with a uniform distribution in all directions, i.e. omnidirectional.
        The position of the point light is defined by its <i>position</i> attribute and affected by the transformation of the light element that defines
        the occurrence of the point light. The orientation of the light element is not influencing the light.
      </p>
    </section>

    <section>
      <h2>Directional Lights</h2>
      <p>URN: <code>urn:xml3d:light:directional</code></p>
      <div class="attributes">Attributes:
        <table>
          <tbody>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Default</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>direction</td>
            <td>float3</td>
            <td>0 0 -1</td>
            <td>The direction of the light in object space.</td>
          </tr>
          <tr>
            <td>intensity</td>
            <td>float3</td>
            <td>1 1 1</td>
            <td>The RGB intensity of the point light.</td>
          </tr>
          </tbody>
        </table>
      </div>
      <p>
        Directional light sources, also known as distant light sources, emit light along parallel rays from an infinite distance away. The direction the light sources
        emits from is defined by its <i>direction</i> attribute and affected by the transformation of the light element that defines
        the occurrence of the distant light. The position of the light element is not taken into account.
      </p>

    </section>

    <section>
      <h2>Spot Lights</h2>  <p>URN: <code>urn:xml3d:light:spot</code></p>
      <div class="attributes">Attributes:
        <table>
          <tbody>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Default</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>position</td>
            <td>float3</td>
            <td>0 0 0</td>
            <td>The position of the point light in object space</td>
          </tr>
          <tr>
            <td>direction</td>
            <td>float3</td>
            <td>0 0 -1</td>
            <td>The direction of the light in object space.</td>
          </tr>
          <tr>
            <td>intensity</td>
            <td>float3</td>
            <td>1 1 1</td>
            <td>The <i>RGB</i> intensity of the directional light.</td>
          </tr>
          <tr>
            <td>attenuation</td>
            <td>float3</td>
            <td>0 0 1</td>
            <td>The attenuation of the point light given as its constant, linear, e.g quadratic component.</td>
          </tr>
          <tr>
            <td>falloffAngle</td>
            <td>float</td>
            <td>Math.PI/4</td>
            <td>Spot angle in radians. Controls the size of the outer cone of a spot light, i.e. the circular area a spot
              light covers.
            </td>
          </tr>
          <tr>
            <td>softness</td>
            <td>float</td>
            <td>0</td>
            <td>Softness of the spot light in the range [0;1].</td>
          </tr>
          </tbody>
        </table>
      </div>
      <div class="issue">Improve description of softness including figure and find a better name for falloffAngle</div>
      <p>
        Spot light source are a variation of point lights: Instead of emitting light omnidirectional, they emit light from their position in a cone of direction.
        The <i>fallOffAngle</i> attribute defines the size of the cone. Objects outside the cone defined by the <i>fallOffAngle</i> are not lit by the light source. The <i>softness</i>
        attribute defines the percentage of the cone in which the illumination ramps down from full to no illumination, i.e. a softness of 0 specifies a hard transition between full to no illumination and a softness of 1.0 a linear transition along the radius of the cone.
      </p>
    </section>
  </section>
  <section>
    <h3>Predefined camera models</h3>
    <section>
      <h4>Perspective</h4>
    </section>
    <section>
      <h4>Projective</h4>
    </section>
  </section>

</section>

<section>
  <h2>Style</h2>
  Since XML3D extends HTML, all [[CSS2]] properties also apply to XML3D elements. However, only the semantic of a few of them make sense for the 3D scene description.
  In the following we list those properties that influence the rendering of the scene.

  <div class="note">Other properties may affect XML3D elements in the future. Good candidates include the <code>visible</code> and <code>pointer-events</code> properties.</div>
  <section>
    <h3>The <code>display</code> property</h3>

    <div class="propdef">
      <dl>
        <dt>
          <span class="index-def" title="'display'"><a name="propdef-display" class="propdef-title"><strong>'display'</strong></a></span>
        </dt>
        <dd>
          <table class="propinfo" cellspacing="0" cellpadding="0">
            <tbody>
            <tr valign="baseline">
              <td><em>Value:</em>&nbsp;&nbsp;</td>
              <td>inline | block | list-item | inline-block |
                table | inline-table | table-row-group | table-header-group |
                table-footer-group | table-row | table-column-group | table-column |
                table-cell | table-caption | none | inherit
              </td>
            </tr>
            <tr valign="baseline">
              <td><em>Initial:</em>&nbsp;&nbsp;</td>
              <td>inherit
              </td>
            </tr>
            <tr valign="baseline">
              <td><em>Applies to:</em>&nbsp;&nbsp;</td>
              <td><a href="#scene-elements">Scene elements</a>
              </td>
            </tr>
            </tbody>
          </table>
        </dd>
      </dl>
    </div>
    <p>The meanings of the values of this property for XML3D elements:</p>
    <dl>
      <dt><span class="index-def" title="'nonde', definition of"><strong>none</strong></span>
      </dt>
      <dd>This value causes an element to not contribute to the rendering, i.e. geometry elements are not rendered, light elements do not emit light
        into the scene. Also, geometry elements do not generate bounding boxes (empty boxes) nor contribute to their parent's bounding box.
        Descendant elements do not display and do not contribute to the parents' bounding boxes either.
      </dd>
      <dt><span class="index-def" title="definition of other values">&lt;other values&gt;</span>
      </dt>
      <dd>All other values do not affect the rendering of the element.
      </dd>
    </dl>
    Here are some examples for the 'display' property:
    <pre class="example highlight">
      mesh.hidden { display: none } /* do not display meshes with hidden class */
      xml3d > * > * > * > * model { display: none; } /* Hide all models deeper than the fifth hierarchy level */
    </pre>

    Modifying the <code>display</code> property with jQuery:
    <pre class="example highlight">
      $("#myMesh").hide();
      $(".walls").toggle();
    </pre>


  </section>

  <section>
    <h3>The <code>transform</code> property</h3>

    <div class="propdef">
      <dl>
        <dt>
          <span class="index-def" title="'transform'"><a name="propdef-transform" class="propdef-title"><strong>'transform'</strong></a></span>
        </dt>
        <dd>
          <table class="propinfo" cellspacing="0" cellpadding="0">
            <tbody>
            <tr valign="baseline">
              <td><em>Values:</em>&nbsp;&nbsp;</td>
              <td>translateX | translateY | translateZ | translate3d | rotateX | rotateY | rotateZ | rotate3d
                | scaleX | scaleY | scaleZ | scale3d | matrix3d
              </td>
            </tr>
            <tr valign="baseline">
              <td><em>Initial:</em>&nbsp;&nbsp;</td>
              <td>identity matrix
              </td>
            </tr>
            <tr valign="baseline">
              <td><em>Applies to:</em>&nbsp;&nbsp;</td>
              <td><a href="#transformable-elements">Transformable elements</a>
              </td>
            </tr>
            </tbody>
          </table>
        </dd>
      </dl>
    </div>

    <p>[[CSS3-transforms]] can be used to specify 3D transformations for any transformable element. The transform property may hold any number and combination of
    values, which will be combined from left to right.</p>

    <div class="note">Some transform functions (eg. <code>translate3d</code>) require a unit of measurement to be valid. Because browsers do not yet support units that make sense
    for a 3D scene these values should be given in 'px'. For example, <code>translate3d(10px, 5px, 0px)</code>. Internally these transformations will of course be in the units that
    the scene uses. </div>

    <div class="note">Some browsers silently ignore invalid CSS transforms. If a CSS transform is not behaving as expected double check to ensure the formatting and syntax are
    valid.</div>

  </section>

</section>

<section>
  <h2>The elements of XML3D</h2>
  <section>
      <h3>Kinds of elements</h3>
      <section>
          <h4>Transformable elements</h4>
          <dl class='element'>
            <a href="#the-assetmesh-element"><code>assetmesh</code></a>,
            <a href="#the-group-element"><code>group</code></a>, <a href="#the-mesh-element"><code>mesh</code></a>,
            <a href="#the-model-element"><code>model</code></a>, <a href="#the-light-element"><code>light</code></a>,
            <a href="#the-view-element"><code>view</code></a>
          </dl>
          <p>Transformable elements are those that are able to be transformed, either through CSS3 transforms or the <a href="#the-transform-element"><code>transform</code></a> element.
           Not all transformable elements can be nested but when they are they build a transformation hierarchy, with the transformation matrix of each node being defined as its own
          local transformation matrix multiplied with the transformation matrix of its parent element. </p>

          <p>A third possibility for defining a transformation is to reference a <a href="#the-data-element"><code>data</code></a> element through the <code>transform</code> attribute instead of a 
          <a href="#the-transform-element"><code>transform</code></a> element. This <code>data</code> element may either contain a single 
            <a href="#the-float-float2-float3-float4-and-float4x4-elements"><code>float4x4</code></a> element with name <code>transform</code> or use a 
            <a href="#the-compute-operator"><code>compute operator</code></a> to generate the transformation matrix. 
          </p>

          <pre class="example highlight">
            &lt;!-- Using a transform element --&gt;
            &lt;transform id="myTransformElement" translation="0 0 10"&gt;&lt;/transform&gt;
            &lt;group transform="#myTransformElement"&gt;&lt;/group&gt;

            &lt;!-- Giving the transformation matrix directly --&gt;
            &lt;data id="myDataTransform"&gt;
              &lt;float4x4 name="transform"&gt;1 0 0 0 0 1 0 0 0 0 1 10 0 0 0 1&lt;/float4x4&gt;
            &lt;/data&gt;
            &lt;group transform="#myDataTransform"&gt;&lt;/group&gt;

            &lt;!-- Computing the transformation matrix with an Xflow operator --&gt;
            &lt;data id="myComputeTransform" compute="transform = xflow.createTransform(translation)"&gt;
              &lt;float3 name="translation"&gt;0 0 10&lt;/float3&gt;
            &lt;/data&gt;
            &lt;group transform="#myComputeTransform"&gt;&lt;/group&gt;

            &lt;!-- Using a CSS3 transform --&gt;
            &lt;group style="transform: translate3d(0px, 0px, 10px)"&gt;&lt;/group&gt;
          </pre>

          <p>The above example shows four different ways of defining the same transformation on a <a href="#the-group-element"><code>group</code></a> element.</p>

      </section>
      <section>
          <h4>Data elements</h4>
          <dl class='element'>
            <a href="#the-assetdata-element"><code>assetdata</code></a>,
            <a href="#the-data-element"><code>data</code></a>, <a href="#the-dataflow-element"><code>dataflow</code></a>,
            <a href="#the-mesh-element"><code>mesh</code></a>, <a href="#the-material-element"><code>material</code></a>,
            <a href="#the-model-element"><code>model</code></a>, <a href="#the-light-element"><code>light</code></a>
          </dl>
          <p>Data elements are the non-leaf nodes of an Xflow graph. They may contain any combination of data elements and <a href="#value-elements">value elements</a>. They may also reference
          other data elements through the <code>src</code> attribute using a standard HTML URI.</p>

          <p>The ultimate function of a graph of data elements is to provide data to a "sink".  Some data sinks in XML3D include the <a href="#the-mesh-element"><code>mesh</code></a> element, the
              <a href="#the-material-element"><code>material</code></a> element and the <a href="#the-view-element"><code>projection</code></a> attribute of the
              <a href="#the-view-element"><code>view</code></a> element. </p>

          <p>The ability to reference data elements makes it possible to share a common set of data between many different sinks. This saves memory and increases performance, as the data is also
          shared internally whenever possible. For example, a set of vertex positions may be shared between many instances of the same mesh using a different set of face indices each time. Internally
          these meshes will also share a common WebGL vertex position buffer:</p>
          <pre class="example highlight">
              &lt;data id="shared_positions"&gt;
                &lt;float3 name="position"&gt; 1.0 0.0 0.0 0.5 1.0 1.0 ... &lt;/float3&gt;
              &lt;/data&gt;
              &lt;mesh&gt;
                &lt;data src="#shared_positions"&gt;&lt;/data&gt;
                &lt;int name="index"&gt; 0 1 2 3 4 5 ... &lt;/int&gt;
              &lt;/mesh&gt;
              &lt;mesh&gt;
                &lt;data src="#shared_positions"&gt;&lt;/data&gt;
                &lt;int name="index"&gt; 3 4 5 0 1 2 ... &lt;/int&gt;
              &lt;/mesh&gt;
          </pre>

          <p>If two data elements containing fields with identical names are present in an XFlow data graph then the value nearest the top will replace any value
            nested deeper within the graph. In this example the value of the <code>color</code> field will be <code>1.0 0.0 0.0</code> when referencing <code>#my-data</code>:</p>

          <pre class='example highlight'>
              &lt;data id="my-data"&gt;
                  &lt;float3 name="color"&gt;1.0 0.0 0.0&lt;/float3&gt; &lt;!-- Overrides the previous color --&gt;
                  &lt;data&gt;
                      &lt;float3 name="color"&gt;1.0 1.0 1.0&lt;/float3&gt;
                  &lt;/data&gt;
              &lt;/data&gt;
         </pre>

      </section>
      <section>
          <h4>Value elements</h4>
          <dl class='element'>
            <a href="#the-float-float2-float3-float4-and-float4x4-elements"><code>float, float2, float3, float4, float4x4</code></a>,
            <a href="#the-int-and-int4-elements"><code>int, int4</code></a>,
            <a href="#the-bool-element"><code>bool</code></a>,
            <a href="#the-texture-element"><code>texture</code></a>
          </dl>
          <p>Value elements are the leaf nodes of an Xflow graph. They may not be nested and may not contain any non-text child elements. Data should be provided as a text node
              containing a space-separated list of values. The tag name determines how this data is interpreted:</p>
          <pre class="example highlight">
              &lt;bool&gt;1 0 0&lt;/bool&gt;     // an array of three boolean values
              &lt;float3&gt;1 0 0&lt;/float3&gt; // a single three-dimensional floating point vector
          </pre>

          <p>The <code>name</code> attribute of a value element acts as an ID for the data contained in this element. It may be referenced in XFlow operators or
              in material shaders.</p>

          <p>If two value elements with the same name are present inside a <a href="#data-elements">data element</a> then the value appearing later in the DOM will be used. In this example the
          value of the <code>color</code> field will be <code>1.0 1.0 1.0</code> when referencing <code>#my-data</code>:</p>

          <pre class='example highlight'>
                &lt;data id="my-data"&gt;
                    &lt;float3 name="color"&gt;1.0 0.0 0.0&lt;/float3&gt;
                    &lt;float3 name="color"&gt;1.0 1.0 1.0&lt;/float3&gt; &lt;!-- Overrides the previous color --&gt;
                &lt;/data&gt;
          </pre>

      </section>
      <section>
          <h4>Interactive elements</h4>
          <dl class='element'>
            <a href="#the-group-element"><code>group</code></a>, <a href="#the-mesh-element"><code>mesh</code></a>,
            <a href="#the-model-element"><code>model</code></a>, <a href="#the-xml3d-element"><code>xml3d</code></a>
          </dl>
          <p>Interactive elements are those which are able to receive mouse event listeners. The list of available mouse event listeners is described in the
          <a href="#events">Events</a> section.</p>

          <p>In order to receive a mouse event an element must have a renderable object somewhere in its subtree for the user to interact with. When the user
          interacts with this object (eg. clicks on it) the relevant MouseEvent will be generated on the <a href="#the-mesh-element"><code>mesh</code></a> or
              <a href="#the-model-element"><code>model</code></a> element and then bubbled up the scene hierarchy. This will continue until the event reaches the
          <a href="#the-xml3d-element"><code>xml3d</code></a> element, or until <code>event.stopPropagation()</code> is called.</p>

          <p>In the following example, when clicking on the object in the scene corresponding to this <a href="#the-mesh-element"><code>mesh</code></a> element,
          both listeners will be triggered in the appropriate order:</p>

           <pre class='example highlight'>
            &lt;group onmousedown="myMouseDownListener(event)"&gt;
                &lt;group&gt;
                    &lt;mesh onmouseup="myMouseUpListener(event)" type="triangles"&gt;&lt;/mesh&gt;
                &lt;/group&gt;
            &lt;/group&gt;
           </pre>

          <div class="note">Object visibility may affect whether or not mouse event listeners are triggered. See the <a href="#style">Style</a>
          section on visibility for more information.</div>

      </section>
  </section>

  <section>
    <h3>The root element</h3>
    <section>

<!-- #xml3d -->

      <h4>The <code>xml3d</code> element</h4>
        <dl class='element'>
          <dt>Categories:</dt>
          <dd><a href="#interactive-elements">Interactive element</a></dd>
        </dl>
      <p>The XML3D element is the root element of an XML3D scene. XML3D will create a <code>canvas</code> element at this position in the DOM to
      display the rendered scene. CSS styles and event listeners from the XML3D element are also applied to the canvas allowing for mouse interaction with the
        XML3D scene. </p>

      <p>A page may have more than one XML3D element, in this case multiple canvases with their own WebGL contexts will be created. It is not possible
      to share any data between XML3D scenes, though several scenes may of course reference the same external documents where shared data can be stored.</p>

      <p>Because XML3D uses HTML ids to reference elements it is important to avoid duplicate ids. For example, a duplicate id for a <code>data</code> element that appears
      in two different XML3D scenes on the same page may lead to undefined behavior. </p>

      <dl title='interface XML3DXml3dElement : HTMLElement' class='idl'>
        <dt>attribute unsigned long width</dt>
        <dd>Horizontal dimension</dd>
        <dt>attribute unsigned long height</dt>
        <dd>Vertical dimension</dd>
        <dt>readonly attribute boolean complete</dt>
        <dd>Returns true if all resources of the root element have been completely downloaded and rendered; otherwise,
          returns false.
        </dd>

        <dt>attribute DOMString view</dt>
        <dd>The view IDL attribute must reflect the respective content attribute of the same name. This defines the <a href="#the-view-element"><code>view</code></a> element
          that XML3D will use when rendering the scene.</dd>

        <dt>attribute Function onframedrawn</dt>
        <dd>Event listener to be executed whenever a new frame has been drawn. Is passed a <a>FrameDrawn</a> event.
        </dd>
        <dt>attribute Function onload</dt>
        <dd>
          Event listener to be executed when the <code>xml3d</code> element has finished loading. This event is fired once after initial loading of the scene is complete, including
          all external resources such as textures or external models. It will <b>not</b> be fired again if subsequent changes to the scene cause more resources to be loaded. When adding
          a listener for this event through JavaScript it may be necessary to check the status of the <code>complete</code> attribute beforehand, as the <code>load</code> event will not
          be resent if it was already dispatched before the listener was registered.
          <div class="note">This event may be preceeded by one or more <a>FrameDrawn</a> events as XML3D continues to redraw the scene even
            as external resources are being loaded.</div>
        </dd>


        <dt>HTMLElement? getElementByPoint()</dt>
        <dd>
            Returns the element at the point with <b>window</b> coordinates x,y if there is a scene element; otherwise, returns
            null.
            <dl class='parameters'>
                <dt>unsigned long x</dt>
                <dd>The x coordinate relative to the top left of the browser window</dd>
                <dt>unsigned long y</dt>
                <dd>The y coordinate relative to the top left of the browser window</dd>
                <dt>optional Vec3 hitPoint</dt>
                <dd>If provided this vector will be filled with the position of the hit point in world space.</dd>
                <dt>optional Vec3 hitNormal</dt>
                <dd>If provided this vector will be filled with the normal of the hit point in world space.</dd>
            </dl>
        </dd>

        <dt>HTMLElement? getElementByRay()</dt>
        <dd>Returns the first element that intersects with ray if the ray intersects with a a scene element; otherwise,
          returns null.
            <dl class='parameters'>
                <dt>ray ray</dt>
                <dd></dd>
                <dt>optional Vec3 hitPoint</dt>
                <dd>If provided this vector will be filled with the position of the hit point in world space.</dd>
                <dt>optional Vec3 hitNormal</dt>
                <dd>If provided this vector will be filled with the normal of the hit point in world space.</dd>
            </dl>
        </dd>



        <dt>Box getLocalBoundingBox()</dt>
        <dd>Returns the bounding box of the scene. Because the XML3D element is the root element the bounding box will be in world space by definition.</dd>

        <dt>Box getWorldBoundingBox()</dt>
        <dd>Returns the bounding box of the scene in world space.</dd>

        <dt>ray generateRay()</dt>
        <dd>
            Uses <a href="https://github.com/fintler/webgl-unproject">WebGL unProject</a> to generate a new ray from the given x,y <b>window</b> coordinates.
            <dl class='parameters'>
                <dt>unsigned long x</dt>
                <dd>The x coordinate relative to the top left of the browser window</dd>
                <dt>unsigned long y</dt>
                <dd>The y coordinate relative to the top left of the browser window</dd>
            </dl>
        </dd>


      </dl>
    </section>
  </section>

  <section>
    <h3>Scene elements</h3>
    <section>

<!-- #group -->

      <h4>The <code>group</code> element</h4>
        <dl class='element'>
            <dt>Categories:</dt>
            <dd><a href="#interactive-elements">Interactive element</a></dd>
            <dd><a href="#transformable-elements">Transformable element</a></dd>
        </dl>
        <p>Group elements are the non-leaf nodes in an XML3D scene tree. They can be used to build transformation hierarchies and to group
        renderable objects together. Groups can be nested, but because they are not Xflow elements they may not hold any
        <a href="#data-elements">data elements</a> and cannot be referenced by other <code>group</code> elements. This means that
        unlike data elements, groups build a tree structure rather than a graph. Each group may only have a single parent.</p>

        <p>Most properties of groups will be inherited by child elements. Each property is inherited differently, as summed up in this table:</p>
        <div class="attributes">
        <table>
            <tbody>
            <tr>
                <th>Property</th>
                <th>Behavior if absent</th>
                <th>Behavior if present</th>
            </tr>
            <tr>
                <td>material</td>
                <td>Inherited from parent group</td>
                <td>Overrides the value from the parent group</td>
            </tr>
            <tr>
                <td>transform</td>
                <td>Inherited from parent group</td>
                <td>Multiplied with parent transformation</td>
            </tr>
            <tr>
                <td>display</td>
                <td>Inherited from parent group</td>
                <td><code>parent.style.display</code> equals <code>none</code> then <code>none</code> else <code>display</code></td>
            </tr>
            <tr>
                <td>event listeners</td>
                <td>Inherited from parent group</td>
                <td>Called in addition to parent listener, unless <code>event.stopPropagation()</code> is invoked</td>
            </tr>
            </tbody>
        </table>
        </div>
        <pre class="example highlight">
            &lt;group style="display: none;" material="#blueMaterial"&gt;
                &lt;group style="display: block;"&gt;
                    &lt;!-- This mesh will not be visible but will inherit #blueMaterial --&gt;
                    &lt;mesh type="triangles"&gt;&lt;/mesh&gt;
                &lt;/group&gt;
            &lt;/group&gt;
        </pre>
        <dl title='interface XML3DGroupElement : HTMLElement' class='idl'>
            <dt>attribute DOMString transform</dt>
            <dd>Accepts a URI fragment referencing a <a href="#the-transform-element"><code>transform</code></a> element. Alternatively a transformation may be defined
            with CSS through the style attribute.</dd>
            <dt>attribute DOMString material</dt>
            <dd>Accepts a URI fragment referencing a <a href="#the-material-element"><code>material</code></a> element. Material is inherited from the parent group if
            this attribute is not present.</dd>
            <dt>Mat4 getWorldMatrix()</dt>
            <dd>Returns the transformation matrix of this group element in world space (includes parent transformations).
            </dd>
            <dt>Mat4 getLocalMatrix()</dt>
            <dd>Returns the local transformation matrix of this group element (does not include parent transformations).
            </dd>
            <dt>Box getLocalBoundingBox()</dt>
            <dd>Returns the bounding box of this group in its local transformation space. This is calculated as the smallest volume containing the
                bounding boxes of all child elements.</dd>

            <dt>Box getWorldBoundingBox()</dt>
            <dd>Returns the bounding box of this group in world space. This is calculated as the smallest volume containing the
            bounding boxes of all child elements.</dd>
        </dl>
    </section>
    <section>

<!-- #view -->

      <h4>The <code>view</code> element</h4>
        <dl class='element'>
            <dt>Categories:</dt>
            <dd><a href="#transformable-elements">Transformable element</a></dd>
        </dl>
        <dl title='interface XML3DViewElement : HTMLElement' class='idl'>
            <dt>attribute Vec3 position</dt>
            <dd>The position of the camera in world space</dd>

            <dt>attribute AxisAngle orientation</dt>
            <dd>The orientation (rotation) of the camera in axis-angle form [x,y,z,a] with the angle expressed in radians.</dd>

            <dt>attribute float fieldofview</dt>
            <dd>The <b>vertical</b> field of view of this camera, expressed in radians.
            </dd>

            <dt>attribute DOMString projection</dt>
            <dd>Overrides the camera's internal projection matrix. The attribute should contain a URI to a data element
                supplying a float4x4 matrix named "projection". This can be used to, for example, create an orthographic camera. </dd>

            <dt>Mat4 getWorldMatrix()</dt>
            <dd>Returns the transformation matrix of this view element in world space.
            </dd>

            <dt>void setUpVector(Vec3 direction)</dt>
            <dd>Change the up vector of the camera. This method changes the current orientation. The up vector will be
                lost if the orientation is explicitly set at a later time.
            </dd>

            <dt>void setDirection(Vec3 direction)</dt>
            <dd>Change the orientation of the camera to look along the given direction vector.
            </dd>

            <dt>Vec3 getDirection()</dt>
            <dd>Returns the current direction of the camera, which is extracted from the orientation.
            </dd>

            <dt>Vec3 getUpVector()</dt>
            <dd>Returns the current up vector of the camera, which is extracted from the orientation.
            </dd>

            <dt>Mat4 getViewMatrix()</dt>
            <dd>Returns the view matrix of the camera (the matrix used to transform from world to view space).
            </dd>

            <dt>void lookAt(Vec3 point)</dt>
            <dd>Change the orientation of the camera to look at the given point.
            </dd>
        </dl>
    </section>
    <section>

<!-- #light -->

      <h4>The <code>light</code> element</h4>
        <dl class='element'>
            <dt>Categories:</dt>
            <dd><a href="#data-elements">Data element</a></dd>
            <dd><a href="#transformable-elements">Transformable element</a></dd>
        </dl>
      <p>The <span class="element-name">light</span> element defines a light source in the scene that emits light based on the light model defined by
      the <a href="#attr-light-model" class="internalDFN">model</a> attribute. The light uses the <a href="h-generic-data-model">generic data model</a> to define the parameters of the referenced material model.
      The coordinate system of the <span class="element-name">light</span> element defines the base coordinate system for the light. However, the final position and direction of the light source can altered by
      specific parameters of the light model.
      </p>
      <p>A light affects all geometry elements within the same scene, i.e. with the same xml3d element as ancestor.</p>
      <div class="issue">Do we need means for or at least a note about filtering the affected elements?</div>
      <p>
      The light model used by the light is defined by the  <dfn id="attr-light-model">model</dfn> attribute.
      If the <code>model</code> attribute is present, it must contain a valid non-empty URN referencing one of the <a href="#predefined-light-models">predefined light models</a>.
      If the URN is empty or references an unknown light model, or if the <code>model</code> attribute is not present, the <a href="#predefined-light-models">directional light</a> model is used.
      <div class="issue">Should we ignore unknown light models instead?</div>
      <div class="note">Currently, XML3D supports predefined light models only. However, similar to materials, we envisage programmable light models for future versions of XML3D.
      </div>


      <p>This example illustrates the use of a single light source based on the predefined directional light model using its default parameters:</p>
       <pre class='example highlight'>
&lt;light&gt;&lt;/light&gt;
       </pre>
      Since no direction for the light source is specified for the light source, the default direction <code>0 0 -1</code> (along the negative z axis) is transformed by the global
      coordinate system of the light element.

     <p>This example illustrates the use of a single light source based on the predefined point light model:</p>
       <pre class='example highlight'>
&lt;light model=&quot;urn:xml3d:light:point&quot;&gt;
  &lt;float3 name=&quot;intensity&quot;&gt;0.8 0.8 1&lt;/float3&gt;
&lt;/light&gt;
       </pre>


       <dl title='interface XML3DLightElement : XML3DDataElement' class='idl'>
        <dt>attribute DOMString model</dt>
        <dd>The <code>model</code> IDL attribute must reflect the <a href="#attr-light-model" class="internalDFN">model</a> content attribute.</dd>
      </dl>
      </p>
    </section>
    <section>

<!-- #mesh -->

      <h4>The <code>mesh</code> element</h4>
        <dl class='element'>
            <dt>Categories:</dt>
            <dd><a href="#data-elements">Data element</a></dd>
            <dd><a href="#interactive-elements">Interactive element</a></dd>
            <dd><a href="#transformable-elements">Transformable element</a></dd>
        </dl>

        <p>A mesh represents a single renderable object in the scene. To be drawn correctly a mesh must either inherit a
            <a href="#the-material-element"><code>material</code></a> from a parent element or assign its own through the <code>material</code> attribute.</p>

        <div class="note">A mesh can only be assigned a single material. Models that contain multiple materials will have to be broken down into separate meshes.</div>

        <p>The simplest way to define a mesh is to include its data directly in the <code>mesh</code> element:</p>

        <pre class='example highlight'>
            &lt;mesh type="triangles" material="#myMaterial"&gt;
                &lt;int name="index"&gt;0 1 2 ... &lt;/int&gt;
                &lt;float3 name="position"&gt;1.0 0.0 0.0 ... &lt;/float3&gt;
                &lt;float3 name="normal"&gt;0.0 1.0 0.0 ... &lt;/float3&gt;
            &lt;/mesh&gt;
        </pre>

        <p>However it's usually a good idea to reference this data instead, either in the same document or in an external document as shown below:</p>

        <pre class='example highlight'>
            &lt;!-- myDataElement is the id of a data element containing the mesh data --&gt;
            &lt;mesh src="myMesh.xml#myDataElement" type="triangles" material="#myMaterial"&gt;&lt;/mesh&gt;
        </pre>

        <p>Each entry in the mesh data is passed on to the material shader in the form of a vertex attribute. A mesh must <i>always</i> supply at least a
        <code>position</code> entry, any others are optional but may be required by a material in order to be rendered properly (eg. <code>normal</code> in
        conjunction with the predefined <code>phong</code> material). </p>

        <p>As with any <a href="#data-elements">data element</a>, a mesh may override certain entries or supply its own. This applies even to material entries:</p>

        <pre class='example highlight'>
            &lt;!-- This mesh will be rendered with a blue diffuseColor even though the material specifies a red one --&gt;
            &lt;mesh src="myMesh.xml#myDataElement" type="triangles" material="#myRedMaterial"&gt;
                &lt;float3 name="diffuseColor"&gt;0.0 0.0 1.0&lt;float3&gt;
            &lt;/mesh&gt;
        </pre>

        <p>In addition to the <code>transform</code> attribute, a transformation matrix for this mesh may also be defined in a <code>float4x4</code> element. This option is
        described in more detail in the section on the <a href="#the-assetmesh-element"><code>assetmesh</code></a> element. This approach actually uses the same Xflow data overriding
        mechanism described above to override the internally computed mesh transformation matrix.</p>

        <dl title='interface XML3DMeshElement : HTMLElement' class='idl'>
            <dt>readonly attribute boolean complete</dt>
            <dd>Returns true if all external resources required by this mesh have been loaded, false otherwise.</dd>

            <dt>attribute DOMString type</dt>
            <dd>The primitive type that this mesh uses. Supported values are <code>triangles</code>, <code>tristrips</code>,
                <code>points</code>, <code>lines</code> and <code>linestrips</code>.</dd>

            <dt>attribute DOMString src</dt>
            <dd>URI reference to another data element containing the data for this mesh. Can be a reference to an external document.</dd>

            <dt>attribute DOMString material</dt>
            <dd>URI reference to a <a href="#the-material-element"><code>material</code></a> element.</dd>

            <dt>attribute DOMString transform</dt>
            <dd>URI reference to a <a href="#the-transform-element"><code>transform</code></a> element.</dd>

            <dt>XML3DDataResult getResult(Array filter)</dt>
            <dd>Returns a XML3DDataResult object containing the data for the fields requested by the given filter, eg.
                <code>["position", "index", "normal"]</code>. This is useful for accessing the mesh data directly through JavaScript.</dd>

            <dt>Array getOutputNames()</dt>
            <dd>Returns the names of the data fields available to this mesh node. </dd>

            <dt>Mat4 getWorldMatrix()</dt>
            <dd>Returns the transformation matrix of this mesh element in world space (includes parent transformations).
            </dd>
            <dt>Mat4 getLocalMatrix()</dt>
            <dd>Returns the local transformation matrix of this mesh element (does not include parent transformations).
            </dd>
            <dt>Box getLocalBoundingBox()</dt>
            <dd>Returns the bounding box of this mesh in object space, without any transformations applied. </dd>

            <dt>Box getWorldBoundingBox()</dt>
            <dd>Returns the bounding box of this mesh in world space.</dd>
        </dl>
    </section>

    <section>
      <!-- #model -->

      <h4>The <code>model</code> element</h4>
      <dl class='element'>
        <dt>Categories:</dt>
        <dd><a href="#data-elements">Data element</a></dd>
        <dd><a href="#interactive-elements">Interactive element</a></dd>
        <dd><a href="#transformable-elements">Transformable element</a></dd>
      </dl>
      <p>A model is an instantiation of an <a href="#the-asset-element"><code>asset</code></a>. This is useful for rendering complex objects
        with many individual meshes or materials. Not only is it easier to insert a single <code>model</code> element into the DOM, it's also much
        more efficient. </p>

      <p>When referencing an external file the URI <i>must</i> contain the id of the <a href="#the-asset-element"><code>asset</code></a> element to
        be instantiated:</p>

          <pre class='example highlight'>
            &lt;model src="myExternalAsset.xml#myAsset"&gt;&lt;/model&gt;
          </pre>

      <p>A model may override data inside the Asset by specifying the <a href="#the-assetmesh-element"><code>assetmesh</code></a> or
        <a href="#the-assetdata-element"><code>assetdata</code></a> element that should be overwritten. For example, to change the material
        of a mesh inside the Asset named "hat" we would define our model tag as follows:</p>

          <pre class='example highlight'>
            &lt;model src="myExternalAsset.xml#myAsset"&gt;
               &lt;assetmesh name="hat" material="#aNewMaterialDefinedLocally"&gt;&lt;/assetmesh&gt;
            &lt;/model&gt;
          </pre>

      This behavior is especially useful in driving animations inside the instantiated asset. Each instance of the <code>model</code> element can have its
      own animation state, even if all reference the same asset. Typically this is done by exposing the animation key through its own <code>assetdata</code>, which
      is then overwritten in the <code>model</code>:

          <pre class='example highlight'>
            &lt;!-- Assuming "myAsset" contains an assetdata element with name "animation" --&gt;
            &lt;model src="myExternalAsset.xml#myAsset"&gt;
               &lt;assetdata name="animation"&gt;
                &lt;float id="animation_key" name="key"&gt;1.0&lt;/float&gt;
              &lt;/assetdata&gt;
            &lt;/model&gt;
          </pre>

      By changing the value of the <code>animation_key</code> through JavaScript we can now control the model's animation state.

      <dl title='interface XML3DModelElement : HTMLElement' class='idl'>
        <dt>attribute DOMString src</dt>
        <dd>URI reference to an <a href="#the-asset-element"><code>asset</code></a> element that this <code>model</code> should instantiate.</dd>

        <dt>attribute DOMString material</dt>
        <dd>URI reference to a <a href="#the-material-element"><code>material</code></a> element. This material will only be used for
          objects that do not define their own material inside the <code>asset</code>.</dd>

        <dt>attribute DOMString transform</dt>
        <dd>URI reference to a <a href="#the-transform-element"><code>transform</code></a> element.</dd>

        <dt>Mat4 getWorldMatrix()</dt>
        <dd>Returns the transformation matrix of this model in world space, including parent transformations.
        </dd>

        <dt>Box getLocalBoundingBox()</dt>
        <dd>Returns the bounding box of this model without any parent transformations applied.</dd>

        <dt>Box getWorldBoundingBox()</dt>
        <dd>Returns the bounding box of this model in world space, including parent transformations.</dd>
      </dl>
    </section>

  </section>

  <section>
    <h3>Definition Areas</h3>
    <section>

<!-- #defs -->

      <h4>The <code>defs</code> element</h4>
        <dl class='element'>
        </dl>
        <p>The defs element is simply an organizational tool to separate the scene tree from elements that are not explicitly
        part of the scene, but may be referenced by elements that are. These implicit elements include <a href="#the-transform-element"><code>transform</code></a>,
        <a href="#the-material-element"><code>material</code></a>, <a href="#the-data-element"><code>data</code></a> and <a href="#the-dataflow-element"><code>dataflow</code></a>. Note that
        any of these elements may appear inside the scene tree as well, it's just good practice to keep them in the <code>defs</code> section
        whenever possible.</p>

        Ideally the only elements that should appear outside the <code>defs</code> section are <a href="#the-group-element"><code>group</code></a>,
        <a href="#the-mesh-element"><code>mesh</code></a>, <a href="#the-model-element"><code>model</code></a>, <a href="#the-view-element"><code>view</code></a> and
        <a href="#the-model-element"><code>light</code></a>.
        Note that these elements will be ignored if they are inside the <code>defs</code> section, since it is not considered part of the scene tree.
        <a href="#the-group-element"><code>data</code></a> elements usually belong in the <code>defs</code> section but may also be part of the
        scene tree if contained by a <a href="#the-mesh-element"><code>mesh</code></a> element.

        <pre class="example highlight" >
          &lt;xml3d&gt;
            &lt;defs&gt;
               &lt;transform id="myTransform" rotation="0 1 0 0.75"&gt;
               &lt;data id="myMeshData" &gt;
                  &lt;float3 name="position"&gt;1.0 0.0 0.0 ...&lt;/float3&gt;
               &lt;/data&gt;
            &lt;/defs&gt;

            &lt;group transform="#myTransform"&gt;
               &lt;mesh src="#myMeshData" type="triangles"&gt;&lt;/mesh&gt;
            &lt;/group&gt;
          &lt;/xml3d&gt;
        </pre>
    </section>
  </section>

  <section>
    <h3>Property elements</h3>
    <section>

<!-- #material -->

      <h4>The <code>material</code> element</h4>
        <dl class='element'>
            <dt>Categories:</dt>
            <dd><a href="#data-elements">Data element</a></dd>
        </dl>
      <p>A material describes the surface shading of an object. Materials are defined using a <span class="element-name">material</span>
      element and then
      referenced by the <a href="#dfn-material-property" class="internalDFN">material</a> property on a given <a href="#scene-elements">scene
      element</a> to indicate that the
      given element shall be shaded using the referenced material. Multiple scene elements can share a material.
      The material uses the generic data model to define the parameters of the referenced material model.
      Note that graphics elements can override the parameters defined in the material element. Hence, the parameters in
      the material element can be considered as default materials.</p>


      <p>
      The material model used by the material is defined by the <dfn id="attr-material-script">script</dfn> attribute.
      The <code>script</code> attribute must be present, and must contain a valid non-empty URL referencing either a <a href="#predefined-material-models">predefined material model</a> or
      a scripted material model, e.g. using shade.js.
      </p>
      <p>Here is a simple example for a material based on the predefined phong material model:</p>
       <pre class='example highlight'>
&lt;material script=&quot;urn:xml3d:material:phong&quot;&gt;
  &lt;float3 name=&quot;diffuseColor&quot;&gt;0 0 1&lt;/float3&gt;
  &lt;texture name=&quot;diffuseTexture&quot;&gt;
    &lt;img src=&quot;../stone.jpg&quot;/&gt;
  &lt;/texture&gt;
&lt;/material&gt;
</pre>

      <dl title='interface XML3DMaterialElement : XML3DDataElement' class='idl'>
        <dt>attribute DOMString script</dt>
        <dd>The <code>script</code> IDL attribute must reflect the <a href="#attr-material-script" class="internalDFN">script</a> content attribute.</dd>
      </dl>
    </section>
    <section>
      <h4>The <code>transform</code> element</h4>
      <dl class='element'>
      </dl>

      <p>In addition to CSS3 transformations applied through the <code>style</code> attribute, <code>transform</code> elements provide another way to define transformations for
        <a href="#transformable-elements">transformable elements</a>. The various transformation components are combined into a transformation matrix which is then applied to the
      element or elements referencing this transform element. </p>

      <p>Transform elements are generally placed into the <a href="#the-defs-element"><code>defs</code></a> section of a scene, however it's possible to define them anywhere inside the
      <a href="#the-xml3d-element"><code>xml3d</code></a> element. No matter where a transform element is defined it must be referenced by its <code>id</code> from the <code>transform</code> attribute
      of a <a href="#transformable-elements">transformable element</a> to be used. A single transform element can be referenced by multiple other elements. </p>

      <dl title='interface XML3DTransformElement : HTMLElement' class='idl'>
        <dt>attribute AxisAngle scaleorientation</dt>
        <dd>The orientation on which to apply the scaling factor supplied by the IDL attribute <i>scale</i>. In axis-angle form [x,y,z,a] with the angle expressed in radians.</dd>
        <dt>attribute AxisAngle rotation</dt>
        <dd>The rotation component of this transformation. In axis-angle form [x,y,z,a] with the angle expressed in radians.</dd>
        <dt>attribute Vec3 translation</dt>
        <dd>The translation component of this transformation.</dd>
        <dt>attribute Vec3 scale</dt>
        <dd>The scale component of this transformation. Note: non-uniform scaling and negative values are allowed.</dd>
        <dt>attribute Vec3 center</dt>
        <dd>The center point of this transformation.</dd>
      </dl>
    </section>
  </section>

  <section>
    <h3>Data and dataflow elements</h3>
    <section>

<!-- #data -->

      <h4>The <code>data</code> element</h4>
        <dl class='element'>
            <dt>Categories:</dt>
            <dd><a href="#data-elements">Data element</a></dd>
        </dl>
        <p>Data elements are the non-leaf nodes in an Xflow graph. They act primarily as containers for data but may also modify that data through
        compute operators and filters. When data elements are nested the data from all child elements is merged, in this sense the parent data element acts as a data
         aggregator. In the case of two data fields with the same name the data element further down the list in the DOM will have priority. For example:</p>

        <pre class='example highlight'>
        &lt;data&gt; &lt;!-- At this level "color" will be "0.0 1.0 0.0" --&gt;
          &lt;data&gt;
            &lt;float3 name="color"&gt;1.0 0.0 0.0&lt;/float3&gt;
          &lt;/data&gt;
          &lt;data&gt;
            &lt;float3 name="color"&gt;0.0 1.0 0.0&lt;/float3&gt;
          &lt;/data&gt;
        &lt;/data&gt;
        </pre>

        <p>Data elements may also reference other data elements. This can be used to share a common dataset between objects, overwriting certain fields on a
        per-object basis as required. See the <a href="#data-elements">data elements</a> section for an example.</p>

        <p>One important use for data elements is to dynamically change or generate data, for example to drive an animation or generate a ground mesh from a height map.
         This can be accomplished with a combination of compute operators and data overrides. The following is an example of a simple compute operator that will add the
        provided offset to all vertex positions of a mesh:</p>

         <pre class='example highlight'>
        &lt;mesh&gt;
           &lt;data compute="position = xflow.add(position, offset)"&gt;
             &lt;float3 name="offset"&gt;0.5 0.5 0.5 ... &lt;/float3&gt;
             &lt;data id="originalData"&gt;
                &lt;float3 name="position"&gt;1.0 0.0 0.0 ... &lt;/float3&gt;
             &lt;/data&gt;
           &lt;/data&gt;
        &lt;/mesh&gt;
        </pre>

        When using a compute operator with a data element all input arguments must be available to the data element that invokes the operator. In this example the
        "position" field of the <code>mesh</code> will contain the offset position data, while the data element with id <code>originalData</code> will contain the
        original positions. If this data element were referenced from another mesh it would also return the original positions:

        <pre class='example highlight'>
        &lt;mesh&gt;
            &lt;!-- "positions" contains the original data 1.0 0.0 0.0 ... --&gt;
           &lt;data src="#originalData"&gt;&lt;/data&gt;
        &lt;/mesh&gt;
        </pre>

        Xflow is designed as a reactive framework, meaning operators will only be recomputed if input data has changed and a sink element has requested the
        output data (eg. during a draw call in a subsequent frame).

       <dl title='interface XML3DDataElement : HTMLElement' class='idl'>
         <dt>readonly attribute boolean complete</dt>
         <dd>Returns true if all external resources required by this data have been loaded, false otherwise.</dd>
         <dt>attribute DOMString compute</dt>
         <dd>A Javascript-like statement that can invoke an Xflow compute operator on a set of input data. See the <a href="#the-compute-operator">compute operator</a>
              section for more information.</dd>
         <dt>attribute DOMString filter</dt>
         <dd>May contain a filter (<code>keep</code>, <code>rename</code> or <code>remove</code>) to adjust the data that is provided by this data element. See the
              Wiki page <a href="https://github.com/xml3d/xml3d.js/wiki/How-to-use-Xflow">How to use Xflow</a> for more information.</dd>
         <dt>attribute DOMString src</dt>
         <dd>Accepts an HTML ID reference to another data element. The other element's data will be included in place of this one. Note that any child elements
             are ignored when the <code>src</code> attribute is set.</dd>
         <dt>XML3DDataResult getResult(Array filter)</dt>
         <dd>Returns a XML3DDataResult object containing the data for the fields requested by the given filter, eg.
              <code>["position", "index", "normal"]</code>. This is useful for accessing the data directly through JavaScript.</dd>

         <dt>Array getOutputNames()</dt>
         <dd>Returns the names of the data fields provided by this data element. </dd>
      </dl>
    </section>

<!-- #dataflow -->

    <section>
      <h4>The <code>dataflow</code> element</h4>
      <dl class='element'>
        <dt>Categories:</dt>
        <dd><a href="#data-elements">Data element</a></dd>
      </dl>

      <p>Dataflow elements can be thought of as templates for a compute operation consisting of several Xflow operators executed in sequence.
        This template can be defined once and then reused many times in the scene, applying the operations to a different set of input data each time.
        Consider the following dataflow example which computes <a href="http://en.wikipedia.org/wiki/Skeletal_animation">skeletal animation</a>
        for a mesh:</p>

       <pre class='example highlight'>
        &lt;dataflow id="skinning" out="position, normal, boneXform"&gt;
          &lt;float3 param="true" name="position" &gt;&lt;/float3&gt;
          &lt;float3 param="true" name="normal" &gt;&lt;/float3&gt;
          &lt;int4   param="true" name="boneIdx" &gt;&lt;/int4&gt;
          &lt;float4 param="true" name="boneWeight" &gt;&lt;/float4&gt;

          &lt;int    param="true" name="boneParent" &gt;&lt;/int&gt;
          &lt;float3 param="true" name="bindTranslation" &gt;&lt;/float3&gt;
          &lt;float4 param="true" name="bindRotation" &gt;&lt;/float4&gt;

          &lt;float3 param="true" name="translation" &gt;&lt;/float3&gt;
          &lt;float4 param="true" name="rotation" &gt;&lt;/float4&gt;

          &lt;float  param="true" name="key" &gt;0&lt;/float&gt;
          &lt;compute&gt;
            bindPose = xflow.createTransformInv({translation: bindTranslation, rotation: bindRotation});
            bindPose = xflow.forwardKinematicsInv(boneParent, bindPose);

            rot = xflow.slerpSeq(rotation, key);
            trans = xflow.lerpSeq(translation, key);
            pose = xflow.createTransform({translation: trans, rotation: rot});
            pose = xflow.forwardKinematics(boneParent, pose);

            boneXform = xflow.mul(bindPose, pose);

            normal = xflow.skinDirection(normal, boneIdx, boneWeight, boneXform);
            position = xflow.skinPosition(position, boneIdx, boneWeight, boneXform);
          &lt;/compute&gt;
        &lt;/dataflow&gt;
        </pre>

      <p>By defining the <code>param</code> attribute of the various <a href="#value-elements">value elements</a> we instruct Xflow to expect them as inputs provided
        by any element that references this dataflow. The <code>compute</code> element is only found inside dataflows and can be used to define a sequence of Xflow operators
        that should be applied to the input data. The list of operators will be computed from top to bottom and any new data fields they create (ie. <code>bindPose</code> in
        this example) can be used as input for operators further down the list.
      </p>

      <p>To apply this dataflow to a set of data another <a href="#data-elements">data element</a> may reference it in its own <code>compute</code> block or attribute:</p>

      <pre class='example highlight'>
        &lt;data compute="position, normal = dataflow['#skinning']"&gt;
          &lt;!-- We assume this file contains all the input data that the 'skinning' dataflow expects --&gt;
          &lt;data src="myMeshData.xml"&gt;&lt;/data&gt;
          &lt;float id="myAnimationKey" name="key"&gt;1.0&lt;float&gt;
        &lt;/data&gt;
      </pre>

      <p>
        Conceptually this data element will 'call' the dataflow element with the input 'arguments' from the file <code>myMeshData.xml</code> and then assign the output
        of the dataflow to the <code>position</code> and <code>normal</code> fields, effectively overwriting the ones found in <code>myMeshData.xml</code>.
        Note the URI fragment inside the <code>dataflow[]</code> construct. This may also reference an external document containing the dataflow.
      </p>

      <p>By declaring the <code>key</code> value separately we can control the animation state of this model. Note also that the key is declared <em>after</em> the reference
      to <code>myMeshData.xml</code> to ensure that it overrides the key value found in the xml file.</p>


      <dl title='interface XML3DDataflowElement : HTMLElement' class='idl'>
        <dt>attribute DOMString out</dt>
        <dd>A comma-separated list of fields that this dataflow provides as output. If this attribute is not present then all computed fields will be provided as output.</dd>
        <dt>readonly attribute boolean complete</dt>
        <dd>Returns true if all external resources required by this dataflow have been loaded, false otherwise.</dd>
        <dt>XML3DDataResult getResult(Array filter)</dt>
        <dd>Returns a XML3DDataResult object containing the data for the fields requested by the given filter, eg.
          <code>["position", "index", "normal"]</code>. This is useful for accessing the data directly through JavaScript.</dd>
        <dt>Array getOutputNames()</dt>
        <dd>Returns the names of the data fields provided by this data element. </dd>
      </dl>
    </section>

    <section>

<!-- #float -->

        <h4>The <code>float</code>, <code>float2</code>, <code>float3</code>, <code>float4</code>, and
            <code>float4x4</code> elements</h4>
        <dl class='element'>
            <dt>Categories:</dt>
            <dd><a href="#value-elements">Value element</a></dd>
        </dl>
        <p>The <code>float*</code> elements hold a space separated list of floating point values. The tag name determines how this data is interpreted, ie. a <code>float2</code> element
            will interpret the data as an array of 2D vectors while a <code>float4x4</code> element will interpret it as an array of 4x4 matrices. </p>

        <dl title='interface XML3DFloatValueElement : HTMLElement' class='idl'>
            <dt>attribute DOMString name</dt>
            <dd>The name of the value element. A good name should be a semantic description of the data that this element holds.</dd>
            <dt>attribute boolean param</dt>
            <dd>Marks this value as one to be supplied by a different data element. Value elements with the <code>param</code> attribute are
                the only value elements that may be empty, all others must contain data. See the <a href="#the-dataflow-element" class="internalDFN">dataflow</a>
                element for example usage.</dd>
            <dt>attribute float key</dt>
            <dd>A keyframe value to assist in defining animated values. A script may, for example, interpolate the data between successive keys.</dd>

            <dt>void setScriptValue(Float32Array value)</dt>
            <dd>
                A high performance setter to set the data of this value element directly through JavaScript.
            </dd>
        </dl>


    </section>
    <section>

<!-- #int -->

      <h4>The <code>int</code> and <code>int4</code> elements</h4>
        <dl class='element'>
            <dt>Categories:</dt>
            <dd><a href="#value-elements">Value element</a></dd>
        </dl>
        <p>The <code>int*</code> elements hold a space separated list of integer values. The tag name determines how this data is interpreted, ie. an <code>int4</code> element
            will interpret the data as an array of 4-component integer vectors. </p>
        <dl title='interface XML3DIntValueElement : HTMLElement' class='idl'>
            <dt>attribute DOMString name</dt>
            <dd>The name of the value element. A good name should be a semantic description of the data that this element holds.</dd>
            <dt>attribute boolean param</dt>
            <dd>Marks this value as one to be supplied by a different data element. Value elements with the <code>param</code> attribute are
                the only value elements that may be empty, all others must contain data. See the <a href="#the-dataflow-element" class="internalDFN">dataflow</a>
                element for example usage.</dd>
            <dt>attribute float key</dt>
            <dd>A keyframe value to assist in defining animated values. A script may, for example, interpolate the data between successive keys.</dd>

            <dt>void setScriptValue(Int16Array value)</dt>
            <dd>
                A high performance setter to set the data of this value element directly through JavaScript.
            </dd>
        </dl>
    </section>
    <section>

<!-- #bool -->

      <h4>The <code>bool</code> element</h4>
        <dl class='element'>
            <dt>Categories:</dt>
            <dd><a href="#value-elements">Value element</a></dd>
        </dl>
        <p>The <code>bool</code> element holds a space separated list of boolean values. The values may be given in string form (<code>true/false</code>) or as integers (<code>1/0</code>). </p>

        <dl title='interface XML3DBoolValueElement : HTMLElement' class='idl'>
            <dt>attribute DOMString name</dt>
            <dd>The name of the value element. A good name should be a semantic description of the data that this element holds.</dd>
            <dt>attribute boolean param</dt>
            <dd>Marks this value as one to be supplied by a different data element. Value elements with the <code>param</code> attribute are
                the only value elements that may be empty, all others must contain data. See the <a href="#the-dataflow-element" class="internalDFN">dataflow</a>
                element for example usage.</dd>
            <dt>attribute float key</dt>
            <dd>A keyframe value to assist in defining animated values. A script may, for example, interpolate the data between successive keys.</dd>

            <dt>void setScriptValue(Int16Array value)</dt>
            <dd>
                A high performance setter to set the data of this value element directly through JavaScript.
            </dd>
        </dl>
    </section>


<!-- #texture -->
    <section>
      <h4>The <code>texture</code> element</h4>
      <dl class='element'>
        <dt>Categories:</dt>
        <dd><a href="#value-elements">Value element</a></dd>
        <dt>Content model:</dt>
        <dd>One or more <code>img</code>, <code>video</code>, or <code>canvas</code> elements</dd>
      </dl>

      The texture element represents a texture that can be used as parameter for materials or as input for generic
      dataflow processing.
      The image data of the texture is defined by its children.
      The texture element's attributes determine how samples are derived from the image.
      <p class="note">
        Texture sampling attributes configure fixed-function sampling methods on the graphics hardware.
        Thus these attributes qualify as CSS properties. We have abstained from using CSS properties because we
        currently cannot define custom CSS properties.
      </p>


      <div>The <dfn id="attr-texture-wrap">wrap</dfn> attribute controls the texture access if the provided texture
        coordinates are outside range [0;1]. The wrap attribute is a combined enumerated attribute.
        A valid wrap value is a string that matches the <code>wrap</code> production of the following form:
      <pre>
        wrap := &lt;wrap-mode&gt; &lt;wrap-mode&gt;?
        wrap-mode := repeat | clamp
      </pre>
        If two <code>wrap-mode</code> values are given, then the first value defines the wrap mode for s coordinates and
        the second for t coordinates. Otherwise the wrap mode is applied in all directions.
        The wrap-mode values correspond to CLAMP_TO_EDGE and REPEAT in OpenGL.

      </div>
      <br>

      <div>The <dfn id="attr-texture-filter">filter</dfn> attribute controls the filtering of the texture, i.e. which
        texture pixel access function is used. The <code>wrap</code> attribute is a combined enumerated attribute.
        A valid filter value is a string that matches the filter production of the following form:
      <pre>
        filter := (&lt;min-filter-mode&gt; &lt;mag-filter-mode&gt;) | &lt;mag-filter-mode&gt;
        min-filter-mode := nearest | linear | nearest-mipmap-nearest | nearest-mipmap-linear | linear-mipmap-nearest | linear-mipmap-linear
        mag-filter-mode := nearest | linear
      </pre>
        If only the <code>mag-filter-mode</code> is given, the specified function is used for both, minifying and
        magnification. Otherwise, the <code>min-filter-mode</code> is used for minifying and the
        <code>mag-filter-mode</code> is used for magnification.
        The functions specified by the filter modes correspond to those in OpenGL (NEAREST, LINEAR,
        NEAREST_MIPMAP_NEAREST, NEAREST_MIPMAP_LINEAR, LINEAR_MIPMAP_NEAREST, and LINEAR_MIPMAP_LINEAR).
        The default filter mode is "linear-mipmap-linear linear".
      </div>

      <p class="note">
        xml3d.js will automatically resize textures to the nearest power-of-two dimensions when the texture wrap mode is
        set to "repeat" or filtermin is set to anything other than "nearest" or
        "linear". See <a
        href="https://www.khronos.org/webgl/wiki/WebGL_and_OpenGL_Differences#Non-Power_of_Two_Texture_Support">WebGL
        limitations</a> for more information.
      </p>

      Here is an example of using the <code>wrap</code> and <code>filter</code> attributes to configure the sampling of a texture:
      <pre class="example highlight">
&lt;texture name=&quot;diffuseTexture&quot; wrap=&quot;repeat clamp&quot; filter=&quot;nearest linear&quot;&gt;
  &lt;img src=&quot;../stone.jpg&quot;/&gt;
&lt;/texture&gt;
      </pre>

       The <dfn id="attr-texture-type">type</dfn>  attribute is an <a href="http://www.w3.org/TR/html5/single-page.html#enumerated-attribute">enumerated attribute</a> with four states with three explicit keywords:
       <dl>
         <dt>The <dfn id="attr-texture-type-1d">1D</dfn> keyword, which maps to the <i>1D</i> state</dt>
         <dd>The 1D state means the children elements define a 1D texture each.</dt>
         <dt>The <dfn id="attr-texture-type-2d">2D</dfn> keyword, which maps to the <i>2D</i> state</dt>
         <dd>The 2D state means the children elements defines a 2D texture.</dd>
         <dt>The <dfn id="attr-texture-type-3d">3D</dfn> keyword, which maps to the <i>3D</i> state</dt>
         <dd>The 3D state means the children elements defines a 3D texture.</dd>
         <dt>The <i>auto</i> state</dt>
         <dd>The type of the texture is determined by the system based on the texture's children elements.</dd>
       </dl>
       <p>The <code><a href="#attr-texture-type" class="internalDFN">type</a></code> attribute's <i>missing value default</i> is the <i>auto</i> state.</p>


      <dl title='interface XML3DTextureElement : HTMLElement' class='idl'>
        <dt>attribute DOMString wrap</dt>
        <dd>The <code>wrap</code> IDL attribute must reflect the respective content attribute of the same name.</dd>
        <dt>attribute DOMString filter</dt>
        <dd>The <code>filter</code> IDL attribute must reflect the respective content attribute of the same name.</dd>
        <dt>attribute DOMString name</dt>
        <dd>Required. The name of the texture as defined by the material shader.</dd>
        <dt>attribute boolean param</dt>
        <dd>If this element appears inside a DataFlow element the param attribute will mark it as a parameter to be
          supplied by the Data element referencing the DataFlow.
        </dd>
        <dt>attribute DOMString type</dt>
        <dd>The <code>type</code></dfn> IDL attribute must reflect the content attribute of the same name, <a href="http://www.w3.org/TR/html5/single-page.html#limited-to-only-known-values">limited to only known values</a>.</dd>
      </dl>
    </section>


  </section>

  <section>
    <h3>Assets</h3>
    <p>The XML3D asset format is designed to encompass everything needed to define a complex model consisting of one or more meshes and materials. Conceptually an asset is
    designed to be static and self-enclosed. When referenced from a <a href="#the-model-element"><code>model</code></a> element an asset behaves as a single object in the scene,
    even though it may be composed of many different meshes. Interaction through mouse event listeners, for example, can only be done on the <code>model</code> level and not
    on the level of individual meshes comprising the asset. </p>

    <p>As with other Xflow elements most parts of the asset (eg. materials, mesh data, transformations) can be overridden inside the <code>model</code> element. However it's important
    to note that adding or removing overrides for assets has a very high performance penalty. Best practice is to define all the necessary overrides during construction of the
    <code>model</code> element and then stick to changing the <i>values</i> of those overrides, which carries no performance penalty. See the
      <a href="https://github.com/xml3d/xml3d.js/wiki/Using-Assets-and-Models#overriding-parts-of-an-asset">XML3D Wiki</a> for more information on how to override asset data.</p>

    <p>It's important to note that unlike a <code>group</code> and <code>mesh</code> hierarchy, assets are always flattened. An asset always consists of an <code>asset</code> element
    with a list of <code>assetmesh</code> elements as children, which cannot be nested. <code>Asset</code> elements themselves, on the other hand, can be nested.</p>

    <section>

<!-- #asset -->

      <h4>The <code>asset</code> element</h4>
        <dl class='element'>
        </dl>

      <p>Defines an asset that can be instantiated through a <a href="#the-model-element"><code>model</code></a> element or extended by another asset. The asset element also
      defines a scope for the <code>name</code> and <code>includes</code> attributes of any child <code>assetdata</code> and <code>assetmesh</code> elements. </p>

      <p>Asset elements may be nested but their <code>id</code> must be unique within the document. </p>

      <dl title='interface XML3DAssetElement : HTMLElement' class='idl'>
        <dt>attribute DOMString src</dt>
        <dd>A URI to another asset that this one should extend.</dd>
      </dl>
    </section>
    <section>

<!-- #assetdata -->

      <h4>The <code>assetdata</code> element</h4>
        <dl class='element'>
            <dt>Categories:</dt>
            <dd><a href="#data-elements">Data element</a></dd>
        </dl>

      <p>Similar to <a href="#the-data-element"><code>data</code></a> elements an assetdata is used to define and share generic data within an asset. Unlike <code>data</code>
      elements, assetdata elements may not be nested and are named by and referenced through a <code>name</code> attribute rather than an <code>id</code>. An assetdata element
      may contain normal <a href="#the-data-element"><code>data</code></a> elements as children.</p>

      <p>Assetdata names must be unique within an <code>asset</code>.</p>

      <dl title='interface XML3DAssetdataElement : HTMLElement' class='idl'>
        <dt>attribute DOMString name</dt>
        <dd>The name of this assetdata element. The name is scoped to the surrounding <code>asset</code> element and may not be duplicated within this scope.</dd>
        <dt>attribute DOMString includes</dt>
        <dd>A space separated list of names corresponding to other <code>assetdata</code> elements that this one should extend.</dd>
      </dl>
    </section>
    <section>

<!-- #assetmesh -->

      <h4>The <code>assetmesh</code> element</h4>
        <dl class='element'>
            <dt>Categories:</dt>
            <dd><a href="#data-elements">Data element</a></dd>
        </dl>

      <p>An assetmesh represents a single drawable mesh in the asset and works similar to the <a href="#the-mesh-element"><code>mesh</code></a> element. Unlike the <code>mesh</code> element
      assetmeshes are identified by their <code>name</code> attribute, which may not be duplicated within the same <a href="#the-asset-element"><code>asset</code></a>.</p>

      <p>In addition to the <code>transform</code> attribute a transformation matrix may be provided for the assetmesh by including a
        <a href="#the-float-float2-float3-float4-and-float4x4-elements"><code>float4x4</code></a> element with the name <code>meshTransform</code> in the assetmesh, as shown below:</p>

      <pre class="example highlight">
        &lt;assetmesh name="exampleMesh" type="triangles" material="#exampleMaterial"&gt;
          &lt;float4x4 name="meshTransform"&gt;1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1&lt;/float4x4&gt;
          &lt;data src="#myMeshData"&gt;&lt;/data&gt;
        &lt;/assetmesh&gt;
      </pre>

      <p>When a transformation matrix is provided in this way it will override any other transforms the assetmesh may have (eg. through the <code>transform</code> or <code>style</code> attributes). </p>
      <div class="note">Supplying a transformation matrix in this way also works for <a href="#the-mesh-element"><code>mesh</code></a> elements. </div>

      <dl title='interface XML3DAssetmeshElement : HTMLElement' class='idl'>
        <dt>attribute DOMString name</dt>
        <dd>The name of this <code>assetmesh</code> element. The name is scoped to the surrounding <code>asset</code> element and may not be duplicated within this scope.</dd>
        <dt>attribute DOMString includes</dt>
        <dd>A space separated list of names corresponding to other <code>assetmesh</code> or <a href="#the-assetdata-element"><code>assetdata</code></a> elements that this one should extend.</dd>
        <dt>attribute DOMString type</dt>
        <dd>The primitive type of this <code>assetmesh</code>. Supported values are <code>triangles</code>, <code>tristrips</code>, <code>points</code>, <code>lines</code> and <code>linestrips</code></dd>
        <dt>attribute DOMString material</dt>
        <dd>URI reference to a <a href="#the-material-element"><code>material</code></a> element. </dd>
        <dt>attribute DOMString transform</dt>
        <dd>URI reference to a <a href="#the-transform-element"><code>transform</code></a> element. </dd>
      </dl>

    </section>

  </section>

</section>

<section>
  <h2>Datatypes</h2>
  <p>XML3D provides a range of math types based on the <a href="http://glmatrix.net/">glMatrix</a> library. In general the functions they provide are
  immutable, with the exception of the <code>Box</code> and <code>Ray</code> types. </p>


  <section>
    <h3>Vec2</h3>
    <dl class='element'>
    </dl>
    <p>A two component vector object.</p>

    <dl title='interface Vec2' class='idl' id="idl-def-Vec2">
      <dt>attribute Float32Array data</dt>
      <dd>The underlying typed array that this Vec2 wraps.</dd>
      <dt>attribute float x</dt>
      <dd>Provides mutable access to the first component of this vector. </dd>
      <dt>attribute float y</dt>
      <dd>Provides mutable access to the second component of this vector.</dd>
      <dt>static Vec2 fromDOMString(DOMString str)</dt>
      <dd>Creates a new Vec2 object from the space-separated string representation as used in XML3D element attributes.</dd>
      <dt>DOMString toDOMString(Vec2 vec)</dt>
      <dd>Converts a Vec2 into the space-seperated string representation used in XML3D element attributes.</dd>

      <dt>Vec2 add(Vec2 other)</dt>
      <dd>Returns the component wise addition of the two vectors as a new Vec2.</dd>
      <dt>Vec2 clone()</dt>
      <dd>Returns a new copy of this Vec2.</dd>
      <dt>float dist(Vec2 other)</dt>
      <dd>The distance between this and the given vector.</dd>
      <dt>Vec2 divide(Vec2 other)</dt>
      <dd>Returns the component wise division of the two vectors as a new Vec2.</dd>
      <dt>float dot(Vec2 other)</dt>
      <dd>The dot product of this and the given vector.</dd>
      <dt>static Vec2 fromValues(float x, float y)</dt>
      <dd>Creates a new Vec2 from the given values.</dd>
      <dt>float length()</dt>
      <dd>Returns the length of this vector.</dd>
      <dt>Vec2 lerp()</dt>
      <dd>Returns a linear interpolation between the two vectors as a new Vec2.
        <dl class='parameters'>
          <dt>Vec2 other</dt>
          <dd></dd>
          <dt>float weight</dt>
          <dd>Interpolation amount between the two vectors, range of [0,1].</dd>
        </dl>
      </dd>
      <dt>Vec2 max(Vec2 other)</dt>
      <dd>Returns a new Vec2 that contains the component wise maximum of the two vectors.</dd>
      <dt>Vec2 min(Vec2 other)</dt>
      <dd>Returns a new Vec2 that contains the component wise minimum of the two vectors.</dd>
      <dt>Vec2 mul(Vec2 other)</dt>
      <dd>Returns the component wise multiplication of the two vectors as a new Vec2.</dd>
      <dt>Vec2 negate()</dt>
      <dd>Returns the component wise negation of this vector as a new Vec2.</dd>
      <dt>Vec2 normalize()</dt>
      <dd>Returns the normalized representation of this vector as a new Vec2.</dd>
      <dt>static Vec2 random(optional float scale)</dt>
      <dd>Generates a random vector with the given scale, or a unit vector if omitted.</dd>
      <dt>Vec2 scale(float scale)</dt>
      <dd>Returns the scaled vector as a new Vec2.</dd>
      <dt>Vec2 sub(Vec2 other)</dt>
      <dd>Returns the component wise subtraction of the two vectors as a new Vec2.</dd>
      <dt>Vec2 transformMat2(Mat2 mat)</dt>
      <dd>Returns the transformation of this vector with the given 2x2 matrix as a new Vec2.</dd>
      <dt>Vec2 transformMat3(Mat3 mat)</dt>
      <dd>Returns the transformation of this vector with the given 3x3 matrix as a new Vec2. The third vector component is implicitly '1'. </dd>
      <dt>Vec2 transformMat4(Mat4 mat)</dt>
      <dd>Returns the transformation of this vector with the given 4x4 matrix as a new Vec2. The third vector component is implicitly '0', the fourth '1'. </dd>
      <dt>static Vec2 wrap(Float32Array data)</dt>
      <dd>Returns a new Vec2 wrapper around the given Float32Array. Note: Changes to the returned Vec2 will also change the data in the array!</dd>
    </dl>
  </section>
  <section>
    <h3>Vec3</h3>
    <dl class='element'>
    </dl>
    <p>A three component vector object.</p>

    <dl title='interface Vec3' class='idl' id="idl-def-Vec3">
      <dt>attribute Float32Array data</dt>
      <dd>The underlying typed array that this Vec3 wraps.</dd>
      <dt>attribute float x</dt>
      <dd>Provides mutable access to the first component of this vector. </dd>
      <dt>attribute float y</dt>
      <dd>Provides mutable access to the second component of this vector.</dd>
      <dt>attribute float z</dt>
      <dd>Provides mutable access to the third component of this vector.</dd>
      <dt>static Vec3 fromDOMString(DOMString str)</dt>
      <dd>Creates a new Vec3 object from the space-separated string representation as used in XML3D element attributes.</dd>
      <dt>DOMString toDOMString(Vec3 vec)</dt>
      <dd>Converts a Vec3 into the space-seperated string representation used in XML3D element attributes.</dd>

      <dt>Vec3 add(Vec3 other)</dt>
      <dd>Returns the component wise addition of the two vectors as a new Vec3.</dd>
      <dt>Vec3 clone()</dt>
      <dd>Returns a new copy of this Vec3.</dd>
      <dt>Vec3 cross(Vec3 other)</dt>
      <dd>Returns the cross product of this and the other vector as a new Vec3.</dd>
      <dt>float dist(Vec3 other)</dt>
      <dd>The distance between this and the given vector.</dd>
      <dt>Vec3 divide(Vec3 other)</dt>
      <dd>Returns the component wise division of the two vectors as a new Vec3.</dd>
      <dt>float dot(Vec3 other)</dt>
      <dd>The dot product of this and the given vector.</dd>
      <dt>static Vec3 fromValues(float x, float y, float z)</dt>
      <dd>Creates a new Vec3 from the given values.</dd>
      <dt>float length()</dt>
      <dd>Returns the length of this vector.</dd>
      <dt>Vec3 lerp()</dt>
      <dd>Returns a linear interpolation between the two vectors as a new Vec3.
        <dl class='parameters'>
          <dt>Vec3 other</dt>
          <dd></dd>
          <dt>float weight</dt>
          <dd>Interpolation amount between the two vectors, range of [0,1].</dd>
        </dl>
      </dd>
      <dt>Vec3 max(Vec3 other)</dt>
      <dd>Returns a new Vec3 that contains the component wise maximum of the two vectors.</dd>
      <dt>Vec3 min(Vec3 other)</dt>
      <dd>Returns a new Vec3 that contains the component wise minimum of the two vectors.</dd>
      <dt>Vec3 mul(Vec3 other)</dt>
      <dd>Returns the component wise multiplication of the two vectors as a new Vec3.</dd>
      <dt>Vec3 negate()</dt>
      <dd>Returns the component wise negation of this vector as a new Vec3.</dd>
      <dt>Vec3 normalize()</dt>
      <dd>Returns the normalized representation of this vector as a new Vec3.</dd>
      <dt>static Vec3 random(optional float scale)</dt>
      <dd>Generates a random vector with the given scale, or a unit vector if omitted.</dd>
      <dt>Vec3 reciprocal()</dt>
      <dd>Returns the component wise reciprocal of this vector as a new Vec3.</dd>
      <dt>Vec3 scale(float scale)</dt>
      <dd>Returns the scaled vector as a new Vec3.</dd>
      <dt>Vec3 sub(Vec3 other)</dt>
      <dd>Returns the component wise subtraction of the two vectors as a new Vec3.</dd>
      <dt>Vec3 transformMat3(Mat3 mat)</dt>
      <dd>Returns the transformation of this vector with the given 3x3 matrix as a new Vec3.</dd>
      <dt>Vec3 transformMat4(Mat4 mat)</dt>
      <dd>Returns the transformation of this vector with the given 4x4 matrix as a new Vec3. The fourth vector component is implicitly '1'</dd>
      <dt>Vec3 transformDirection(Mat4 mat)</dt>
      <dd>Returns the transformation of this vector with the given 4x4 matrix as a new Vec3. The fourth vector component is implicitly '0'</dd>
      <dt>Vec3 transformQuat(Quat q)</dt>
      <dd>Returns the transformation of this vector with the given quaternion as a new Vec3.</dd>
      <dt>static Vec3 wrap(Float32Array data)</dt>
      <dd>Returns a new Vec3 wrapper around the given Float32Array. Note: Changes to the returned Vec3 will also change the data in the array!</dd>
    </dl>
  </section>
  <section>
    <h3>Vec4</h3>
    <dl class='element'>
    </dl>
    <p>A four component vector object.</p>

    <dl title='interface Vec4' class='idl' id="idl-def-Vec4">
      <dt>attribute Float32Array data</dt>
      <dd>The underlying typed array that this Vec4 wraps.</dd>
      <dt>attribute float x</dt>
      <dd>Provides mutable access to the first component of this vector. </dd>
      <dt>attribute float y</dt>
      <dd>Provides mutable access to the second component of this vector.</dd>
      <dt>attribute float z</dt>
      <dd>Provides mutable access to the third component of this vector.</dd>
      <dt>attribute float w</dt>
      <dd>Provides mutable access to the fourth component of this vector.</dd>
      <dt>static Vec4 fromDOMString(DOMString str)</dt>
      <dd>Creates a new Vec4 object from the space-separated string representation as used in XML3D element attributes.</dd>
      <dt>DOMString toDOMString(Vec4 vec)</dt>
      <dd>Converts a Vec4 into the space-seperated string representation used in XML3D element attributes.</dd>

      <dt>Vec4 add(Vec4 other)</dt>
      <dd>Returns the component wise addition of the two vectors as a new Vec4.</dd>
      <dt>Vec4 clone()</dt>
      <dd>Returns a new copy of this Vec4.</dd>
      <dt>float dist(Vec4 other)</dt>
      <dd>The distance between this and the given vector.</dd>
      <dt>Vec4 divide(Vec4 other)</dt>
      <dd>Returns the component wise division of the two vectors as a new Vec4.</dd>
      <dt>float dot(Vec4 other)</dt>
      <dd>The dot product of this and the given vector.</dd>
      <dt>static Vec4 fromValues(float x, float y, float z, float w)</dt>
      <dd>Creates a new Vec4 from the given values.</dd>
      <dt>float length()</dt>
      <dd>Returns the length of this vector.</dd>
      <dt>Vec4 lerp()</dt>
      <dd>Returns a linear interpolation between the two vectors as a new Vec4.
        <dl class='parameters'>
          <dt>Vec4 other</dt>
          <dd></dd>
          <dt>float weight</dt>
          <dd>Interpolation amount between the two vectors, range of [0,1].</dd>
        </dl>
      </dd>
      <dt>Vec4 max(Vec4 other)</dt>
      <dd>Returns a new Vec4 that contains the component wise maximum of the two vectors.</dd>
      <dt>Vec4 min(Vec4 other)</dt>
      <dd>Returns a new Vec4 that contains the component wise minimum of the two vectors.</dd>
      <dt>Vec4 mul(Vec4 other)</dt>
      <dd>Returns the component wise multiplication of the two vectors as a new Vec4.</dd>
      <dt>Vec4 negate()</dt>
      <dd>Returns the component wise negation of this vector as a new Vec4.</dd>
      <dt>Vec4 normalize()</dt>
      <dd>Returns the normalized representation of this vector as a new Vec4.</dd>
      <dt>static Vec4 random(optional float scale)</dt>
      <dd>Generates a random vector with the given scale, or a unit vector if omitted.</dd>
      <dt>Vec4 scale(float scale)</dt>
      <dd>Returns the scaled vector as a new Vec4.</dd>
      <dt>Vec4 sub(Vec4 other)</dt>
      <dd>Returns the component wise subtraction of the two vectors as a new Vec4.</dd>
      <dt>Vec4 transformMat4(Mat4 mat)</dt>
      <dd>Returns the transformation of this vector with the given 4x4 matrix as a new Vec4.</dd>
      <dt>Vec4 transformQuat(Quat q)</dt>
      <dd>Returns the transformation of this vector with the given quaternion as a new Vec4.</dd>
      <dt>static Vec4 wrap(Float32Array data)</dt>
      <dd>Returns a new Vec4 wrapper around the given Float32Array. Note: Changes to the returned Vec4 will also change the data in the array!</dd>
    </dl>
  </section>
  <section>
    <h3>AxisAngle</h3>
    <dl class='element'>
    </dl>
    <p>An axis-angle representation of a rotation with the angle in radians. This type is used for all XML3D interface methods and element attributes that expect a rotation. 
    When working with rotations mathematically it's best to first convert the AxisAngle representation to a Quat and convert back to AxisAngle when 
    passing the result back to an XML3D interface.</p>

    <dl title='interface AxisAngle' class='idl'>
      <dt>attribute Float32Array data</dt>
      <dd>The underlying typed array that this AxisAngle wraps in the form <code>[x, y, z, angle]</code></dd>
      <dt>attribute Vec3 axis</dt>
      <dd>Provides mutable access to the axis vector.</dd>
      <dt>attribute float angle</dt>
      <dd>Provides mutable access to the angle component. The angle should always be in radians. </dd>
      <dt>static AxisAngle fromDOMString(DOMString str)</dt>
      <dd>Creates a new AxisAngle object from the space-separated string representation as used in XML3D element attributes.</dd>
      <dt>DOMString toDOMString(AxisAngle vec)</dt>
      <dd>Converts a AxisAngle into the space-seperated string representation used in XML3D element attributes.</dd>

      <dt>AxisAngle clone()</dt>
      <dd>Returns a new copy of this AxisAngle.</dd>
      <dt>static AxisAngle fromValues(float x, float y, float z, float angleInRadians)</dt>
      <dd>Creates a new AxisAngle from the given values.</dd>
      <dt>static AxisAngle fromQuat(Quat q)</dt>
      <dd>Creates a new axis-angle representation of the given quaternion's rotation.</dd>
      <dt>Quat toQuat()</dt>
      <dd>Creates a new quaternion representation of this AxisAngle's rotation.</dd>
      <dt>static AxisAngle wrap(Float32Array data)</dt>
      <dd>Returns a new AxisAngle wrapper around the given Float32Array. Note: Changes to the returned AxisAngle will also change the data in the array!</dd>
    </dl>
  </section>
  
  <section>
    <h3>Quat</h3>
    <dl class='element'>
    </dl>
    <p>Quat represents a rotation as a quaternion of the form [x, y, z, w]. </p>

    <dl title='interface Quat' class='idl'>
      <dt>attribute Float32Array data</dt>
      <dd>The underlying typed array that this Quat wraps.</dd>
      <dt>attribute float x</dt>
      <dd>Provides mutable access to the first component of this quaternion. </dd>
      <dt>attribute float y</dt>
      <dd>Provides mutable access to the second component of this quaternion.</dd>
      <dt>attribute float z</dt>
      <dd>Provides mutable access to the third component of this quaternion.</dd>
      <dt>attribute float w</dt>
      <dd>Provides mutable access to the fourth component of this quaternion.</dd>
      <dt>static Quat fromDOMString(DOMString str)</dt>
      <dd>Creates a new Quat object from a space-separated string representation.</dd>
      <dt>DOMString toDOMString(Quat vec)</dt>
      <dd>Converts a Quat into a space-seperated string representation.</dd>

      <dt>Quat add(Quat other)</dt>
      <dd>Returns the addition of the two quaternions as a new Quat.</dd>
      <dt>Quat clone()</dt>
      <dd>Returns a new copy of this Quat.</dd>
      <dt>Quat calculateW()</dt>
      <dd>Returns a new Quat with the w component calculated from the x,y,z components of this quaternion. Any existing w component will be ignored.</dd>
      <dt>Quat conjugate()</dt>
      <dd>Returns the conjugate of this quaternion as a new Quat. Note: This method should only be used on normalized quaternions!</dd>
      <dt>float dot(Quat other)</dt>
      <dd>Returns the dot product of the two quaternions.</dd>
      <dt>Quat invert()</dt>
      <dd>Returns the inverse of this quaternion as a new Quat. This is slower than <code>Quat.conjugate</code> but also works on non-normalized quaternions.</dd>
      <dt>float length()</dt>
      <dd>Returns the magnitude of this quaternion.</dd>
      <dt>Quat lerp()</dt>
      <dd>Returns a linear interpolation between the two quaternions as a new Quat.
        <dl class='parameters'>
          <dt>Quat other</dt>
          <dd></dd>
          <dt>float weight</dt>
          <dd>Interpolation amount between the two quaternions, range of [0,1].</dd>
        </dl>
      </dd>
      <dt>Quat mul(Quat other)</dt>
      <dd>Returns the component wise multiplication of the two quaternions as a new Quat.</dd>
      <dt>Quat normalize()</dt>
      <dd>Returns the normalized representation of this quaternion as a new Quat.</dd>
      <dt>Quat rotateX(float angleInRadians)</dt>
      <dd>Returns a new quaternion representing this one rotated around the X axis by the given angle.</dd>
      <dt>Quat rotateY(float angleInRadians)</dt>
      <dd>Returns a new quaternion representing this one rotated around the Y axis by the given angle.</dd>
      <dt>Quat rotateZ(float angleInRadians)</dt>
      <dd>Returns a new quaternion representing this one rotated around the Z axis by the given angle.</dd>
      <dt>Quat scale(float scale)</dt>
      <dd>Returns the scaled quaternion as a new Quat. This is identical to <a>Vec4</a>.scale.</dd>
      <dt>static Quat fromAxisAngle(AxisAngle a)</dt>
      <dd>Generates a quaternion representation of the given AxisAngle.</dd>
      <dt>static Quat fromBasis(Vec3 x, Vec3 y, Vec3 z)</dt>
      <dd>Generates a quaternion from the given basis vectors, defined as the rotation between the coordinate space defined by these vectors and the standard space.</dd>
      <dt>static Quat fromMat3(Mat3 mat)</dt>
      <dd>Generates a quaternion from the given rotation matrix.</dd>
      <dt>static Quat fromRotationTo(Vec3 from, Vec3 to)</dt>
      <dd>Generates a quaternion representing the shortest rotation from one vector to another.</dd>
      <dt>Quat slerp()</dt>
      <dd>Returns a spherical linear interpolation between the two quaternions as a new Quat.
        <dl class='parameters'>
          <dt>Quat other</dt>
          <dd></dd>
          <dt>float weight</dt>
          <dd>Interpolation amount between the two quaternions, range of [0,1].</dd>
        </dl>
      </dd>
      <dt>static Quat wrap(Float32Array data)</dt>
      <dd>Returns a new Quat wrapper around the given Float32Array. Note: Changes to the returned Quat will also change the data in the array!</dd>
    </dl>
  </section>
  
  <section>
    <h3>Mat2</h3>
    <dl class='element'>
    </dl>
    <p>A 2x2 matrix object.</p>

    <dl title='interface Mat2' class='idl' id="idl-def-Mat2">
      <dt>attribute Float32Array data</dt>
      <dd>The underlying typed array that this Mat2 wraps.</dd>
      <dt>attribute float m11</dt>
      <dd>Provides mutable access to the first column of the first row of this matrix.</dd>
      <dt>attribute float m12</dt>
      <dd>Provides mutable access to the second column of the first row of this matrix.</dd>
      <dt>attribute float m21</dt>
      <dd>Provides mutable access to the first column of the second row of this matrix.</dd>
      <dt>attribute float m22</dt>
      <dd>Provides mutable access to the second column of the second row of this matrix.</dd>

      <dt>Mat2 adjoint()</dt>
      <dd>Computes the adjugate of this matrix as a new Mat2.</dd>
      <dt>Mat2 clone()</dt>
      <dd>Returns a new copy of this Mat2.</dd>
      <dt>float determinant()</dt>
      <dd>Computes the determinant of this matrix.</dd>
      <dt>Mat2 invert()</dt>
      <dd>Returns the inverse of this matrix as a new Mat2. If this matrix is not invertible <code>null</code> will be returned.</dd>

      <dt>Mat2 mul(Mat2 other)</dt>
      <dd>Returns the multiplication of this matrix with the other as a new Mat2.</dd>
      <dt>Mat2 rotate(float angleInRadians)</dt>
      <dd>Returns the rotation of this matrix by the given angle in radians as a new Mat2.</dd>
      <dt>Mat2 scale(float scale)</dt>
      <dd>Returns the scaled matrix as a new Mat2.</dd>
      <dt>Mat2 transpose()</dt>
      <dd>Returns the transpose of this matrix as a new Mat2.</dd>
      <dt>static Mat2 wrap(Float32Array data)</dt>
      <dd>Returns a new Mat2 wrapper around the given Float32Array. Note: Changes to the returned Mat2 will also change the data in the array!</dd>
    </dl>
  </section>
  <section>
    <h3>Mat3</h3>
    <dl class='element'>
    </dl>
    <p>A 3x3 matrix object.</p>

    <dl title='interface Mat3' class='idl' id="idl-def-Mat3">
      <dt>attribute Float32Array data</dt>
      <dd>The underlying typed array that this Mat3 wraps.</dd>
      <dt>attribute float m11</dt>
      <dd>Provides mutable access to the first column of the first row of this matrix.</dd>
      <dt>attribute float m12</dt>
      <dd>Provides mutable access to the second column of the first row of this matrix.</dd>
      <dt>attribute float m13</dt>
      <dd>Provides mutable access to the third column of the first row of this matrix.</dd>
      <dt>attribute float m21</dt>
      <dd>Provides mutable access to the first column of the second row of this matrix.</dd>
      <dt>attribute float m22</dt>
      <dd>Provides mutable access to the second column of the second row of this matrix.</dd>
      <dt>attribute float m23</dt>
      <dd>Provides mutable access to the third column of the second row of this matrix.</dd>
      <dt>attribute float m31</dt>
      <dd>Provides mutable access to the first column of the third row of this matrix.</dd>
      <dt>attribute float m32</dt>
      <dd>Provides mutable access to the second column of the third row of this matrix.</dd>
      <dt>attribute float m33</dt>
      <dd>Provides mutable access to the third column of the third row of this matrix.</dd>

      <dt>Mat3 adjoint()</dt>
      <dd>Computes the adjugate of this matrix as a new Mat3.</dd>
      <dt>Mat3 clone()</dt>
      <dd>Returns a new copy of this Mat3.</dd>
      <dt>float determinant()</dt>
      <dd>Computes the determinant of this matrix.</dd>
      <dt>static Mat3 fromMat4(Mat4 mat)</dt>
      <dd>Creates a new Mat3 from the upper-left values of the given 4x4 matrix.</dd>
      <dt>static Mat3 fromQuat(Quat q)</dt>
      <dd>Creates a new 3x3 rotation matrix from the given quaternion.</dd>
      <dt>static Mat3 normalFromMat4(Mat4 mat)</dt>
      <dd>Creates a 3x3 normal matrix (transpose inverse) from the given 4x4 matrix.</dd>
      <dt>Mat3 invert()</dt>
      <dd>Returns the inverse of this matrix as a new Mat3. If this matrix is not invertible <code>null</code> will be returned.</dd>
      <dt>Mat3 mul(Mat3 other)</dt>
      <dd>Returns the multiplication of this matrix with the other as a new Mat3.</dd>
      <dt>Mat3 rotate(float angleInRadians)</dt>
      <dd>Returns the rotation of this matrix by the given angle in radians as a new Mat3.</dd>
      <dt>Mat3 scale(float scale)</dt>
      <dd>Returns the scaled matrix as a new Mat3.</dd>
      <dt>Mat3 translate(Vec3 translation)</dt>
      <dd>Returns the translated matrix as a new Mat3.</dd>
      <dt>Mat3 transpose()</dt>
      <dd>Returns the transpose of this matrix as a new Mat3.</dd>
      <dt>static Mat3 wrap(Float32Array data)</dt>
      <dd>Returns a new Mat3 wrapper around the given Float32Array. Note: Changes to the returned Mat3 will also change the data in the array!</dd>
    </dl>
  </section>

  <section>
    <h3>Mat4</h3>
    <dl class='element'>
    </dl>
    <p>A 4x4 matrix object.</p>

    <dl title='interface Mat4' class='idl' id="idl-def-Mat4">
      <dt>attribute Float32Array data</dt>
      <dd>The underlying typed array that this Mat4 wraps.</dd>
      <dt>attribute float m11</dt>
      <dd>Provides mutable access to the first column of the first row of this matrix.</dd>
      <dt>attribute float m12</dt>
      <dd>Provides mutable access to the second column of the first row of this matrix.</dd>
      <dt>attribute float m13</dt>
      <dd>Provides mutable access to the third column of the first row of this matrix.</dd>
      <dt>attribute float m14</dt>
      <dd>Provides mutable access to the fourth column of the first row of this matrix.</dd>
      <dt>attribute float m21</dt>
      <dd>Provides mutable access to the first column of the second row of this matrix.</dd>
      <dt>attribute float m22</dt>
      <dd>Provides mutable access to the second column of the second row of this matrix.</dd>
      <dt>attribute float m23</dt>
      <dd>Provides mutable access to the third column of the second row of this matrix.</dd>
      <dt>attribute float m24</dt>
      <dd>Provides mutable access to the fourth column of the second row of this matrix.</dd>
      <dt>attribute float m31</dt>
      <dd>Provides mutable access to the first column of the third row of this matrix.</dd>
      <dt>attribute float m32</dt>
      <dd>Provides mutable access to the second column of the third row of this matrix.</dd>
      <dt>attribute float m33</dt>
      <dd>Provides mutable access to the third column of the third row of this matrix.</dd>
      <dt>attribute float m34</dt>
      <dd>Provides mutable access to the fourth column of the third row of this matrix.</dd>
      <dt>attribute float m41</dt>
      <dd>Provides mutable access to the first column of the fourth row of this matrix.</dd>
      <dt>attribute float m42</dt>
      <dd>Provides mutable access to the second column of the fourth row of this matrix.</dd>
      <dt>attribute float m43</dt>
      <dd>Provides mutable access to the third column of the fourth row of this matrix.</dd>
      <dt>attribute float m44</dt>
      <dd>Provides mutable access to the fourth column of the fourth row of this matrix.</dd>

      <dt>Mat4 adjoint()</dt>
      <dd>Computes the adjugate of this matrix as a new Mat4.</dd>
      <dt>Mat4 clone()</dt>
      <dd>Returns a new copy of this Mat4.</dd>
      <dt>float determinant()</dt>
      <dd>Computes the determinant of this matrix.</dd>
      <dt>static Mat4 frustum(float left, float right, float bottom, float top, float near, float far)</dt>
      <dd>Generates a frustum matrix with the given bounds.</dd>
      <dt>Mat4 invert()</dt>
      <dd>Returns the inverse of this matrix as a new Mat4. If this matrix is not invertible <code>null</code> will be returned.</dd>
      <dt>static Mat4 lookAt(Vec3 eye, Vec3 center, Vec3 up)</dt>
      <dd>Generates a look-at matrix with the given eye position, focal point and up axis.</dd>
      <dt>Mat4 mul(Mat4 other)</dt>
      <dd>Returns the multiplication of this matrix with the other as a new Mat4.</dd>
      <dt>static Mat4 ortho(float left, float right, float bottom, float top, float near, float far)</dt>
      <dd>Generates an orthogonal projection matrix with the given bounds.</dd>
      <dt>static Mat4 perspective(float left, float right, float bottom, float top, float near, float far)</dt>
      <dd>Generates a perspective projection matrix with the given bounds.</dd>
      <dt>Mat4 rotate(float angleInRadians, Vec3 axis)</dt>
      <dd>Returns the rotation of this matrix by the given angle around the given axis as a new Mat4.</dd>
      <dt>Mat4 rotateX(float angleInRadians)</dt>
      <dd>Returns the rotation of this matrix by the given angle around the X axis as a new Mat4.</dd>
      <dt>Mat4 rotateY(float angleInRadians)</dt>
      <dd>Returns the rotation of this matrix by the given angle around the Y axis as a new Mat4.</dd>
      <dt>Mat4 rotateZ(float angleInRadians)</dt>
      <dd>Returns the rotation of this matrix by the given angle around the Z axis as a new Mat4.</dd>
      <dt>Mat4 scale(float scale)</dt>
      <dd>Returns the scaled matrix as a new Mat4.</dd>
      <dt>Mat4 translate(Vec3 translation)</dt>
      <dd>Returns the translated matrix as a new Mat4.</dd>
      <dt>Mat4 transpose()</dt>
      <dd>Returns the transpose of this matrix as a new Mat4.</dd>
      <dt>static Mat4 fromQuat(Quat q)</dt>
      <dd>Generates a 4x4 rotation matrix from the given quaternion.</dd>
      <dt>static Mat4 fromRotationTranslation(Quat rotation, Vec3 translation)</dt>
      <dd>Generates a matrix representing the given rotation and translation. This is much faster than setting the transformations individually.</dd>
      <dt>static Mat4 wrap(Float32Array data)</dt>
      <dd>Returns a new Mat4 wrapper around the given Float32Array. Note: Changes to the returned Mat4 will also change the data in the array!</dd>
    </dl>
  </section>

  <section>
    <h3>Box</h3>
    <dl class='element'>
    </dl>
    <p>The Box type represents a bounding box with a stored minimum and maximum point. Unlike the math types the methods of the Box object are mutable and, when applicable,
    return the same instance of the Box.</p>

    <dl title='interface Box' class='idl'>
      <dt>attribute Float32Array data</dt>
      <dd>The underlying typed array that this Box wraps.</dd>
      <dt>attribute Vec3 min</dt>
      <dd>Mutable accessor to the minimum point of this bounding box.</dd>
      <dt>attribute Vec3 max</dt>
      <dd>Mutable accessor to the maximum point of this bounding box.</dd>

      <dt>Box clone()</dt>
      <dd>Returns a new clone of this bounding box.</dd>
      <dt>Box copy(Box other)</dt>
      <dd>Copies the minimum and maximum points from the other bounding box into this one. </dd>

      <dt>Box copyMin(Box other)</dt>
      <dd>Copies only the minimum point from the given Box.</dd>
      <dt>Box copyMax(Box other)</dt>
      <dd>Copies only the maximum point from the given Box.</dd>
      <dt>Box extend(Box other)</dt>
      <dd>Expands this box to also enclose the given box. This method respects axis alignment if both boxes are axis aligned.</dd>
      <dt>Box setEmpty()</dt>
      <dd>Resets this box to the empty state.</dd>
      <dt>boolean isEmpty()</dt>
      <dd>Returns true if the box is empty. Empty is defined as any box whose minimum point is greater than its maximum.</dd>
      <dt>Vec3 center()</dt>
      <dd>Returns the center of this box as a new Vec3.</dd>
      <dt>Vec3 size()</dt>
      <dd>Returns the size of this box as a new Vec3.</dd>
      <dt>Vec3 extent()</dt>
      <dd>Returns the extent of this box as a new Vec3, defined as half of its size.</dd>
      <dt>Box transformAxisAligned(Mat4 mat)</dt>
      <dd>Transforms this box with the given transformation matrix. This box will remain axis-aligned.</dd>
      <dt>Box transform(Mat4 mat)</dt>
      <dd>Transforms this box with the given transformation matrix. This method does not enforce axis alignment./dd>
      <dt>float longestSide()</dt>
      <dd>Returns the length of the longest side of this box.</dd>
      <dt>boolean intersects()</dt>
      <dd>
        <dl class='parameters'>
          <dt>Ray r</dt>
          <dd></dd>
          <dt>optional Object opt</dt>
          <dd>If <code>opt.dist</code> exists then the distance to the intersection point will be written into this field. If the ray does
            not intersect then this field will hold <code>Infinity</code></dd>
        </dl>

        Returns true if the given ray intersects this box.
      </dd>
      <dt>DOMString toString()</dt>
      <dd>A human readable string representation of this box.</dd>
    </dl>
  </section>
  <section>
    <h3>Ray</h3>
    <dl class='element'>
    </dl>
    <p>The Ray type represents a ray with an origin and a direction. Unlike the math types Rays are mutable and methods will return the same instance, if applicable.</p>

    <dl title='interface Ray' class='idl'>
      <dt>attribute Float32Array data</dt>
      <dd>The underlying typed array that this Ray wraps.</dd>
      <dt>attribute Vec3 origin</dt>
      <dd>Mutable accessor to the origin point of this ray.</dd>
      <dt>attribute Vec3 direction</dt>
      <dd>Mutable accessor to the direction of this ray. Assignments should always be normalized.</dd>

      <dt>Ray clone()</dt>
      <dd>Returns a new clone of this ray.</dd>
      <dt>Ray copy(Ray other)</dt>
      <dd>Copies the origin and direction from the other ray into this one. </dd>

      <dt>Ray copyOrigin(Ray other)</dt>
      <dd>Copies only the origin from the given Ray.</dd>
      <dt>Ray copyMax(Ray other)</dt>
      <dd>Copies only the direction from the given Ray.</dd>
      <dt>Box setFromOriginDirection(Vec3 origin, Vec3 direction)</dt>
      <dd>Sets the origin and direction of this ray to the given values.</dd>
      <dt>boolean intersects()</dt>
      <dd>
        <dl class='parameters'>
          <dt>Box box</dt>
          <dd></dd>
          <dt>optional Object opt</dt>
          <dd>If <code>opt.dist</code> exists then the distance to the intersection point will be written into this field. If the ray does
            not intersect then this field will hold <code>Infinity</code></dd>
        </dl>

        Returns true if this ray intersects the given box.
      </dd>
      <dt>DOMString toString()</dt>
      <dd>A human readable string representation of this ray.</dd>
    </dl>
  </section>
</section>

<section>
  <h2>Xflow</h2>
    <section>
      <h3>Filters</h3>
      <p>Xflow defines three filters that may be applied to data through the <code>filter</code> attribute on <a href="#the-data-element"><code>data</code></a> and
        <a href="#the-dataflow-element"><code>dataflow</code></a> elements. </p>

      <pre>
        filter="keep|remove(field1 [, field2...])"
        filter="rename( { field : newFieldName [, field2 : newFieldName2...] } )"
      </pre>

      <p>A filter does not change the data itself but rather influences how that data is made available to other Xflow elements. For example, using a <code>remove</code>
      filter does not actually remove the data from the Xflow element, it simply hides it from parent elements. </p>

        <p>An Xflow element may only have one filter, if multiple filters are needed they can be applied with nested Xflow elements. </p>

      <pre class="example highlight">
        &lt;data filter="keep(A,D)"&gt;
          &lt;float name="A" &gt;0&lt;/float&gt;
          &lt;float name="B" &gt;1&lt;/float&gt; &lt;!-- will be removed --&gt;
          &lt;float name="C" &gt;1&lt;/float&gt; &lt;!-- will be removed --&gt;
          &lt;float name="D" &gt;1&lt;/float&gt;
        &lt;/data&gt;

        &lt;data filter="remove(D)"&gt;
          &lt;float name="A" &gt;0&lt;/float&gt;
          &lt;float name="B" &gt;1&lt;/float&gt;
          &lt;float name="C" &gt;1&lt;/float&gt;
          &lt;float name="D" &gt;1&lt;/float&gt; &lt;!-- will be removed --&gt;
        &lt;/data&gt;

        &lt;data filter="rename( {A2 : A, B2 : B} )"&gt;
          &lt;float name="A" &gt;0&lt;/float&gt; &lt;!-- will be renamed into A2 --&gt;
          &lt;float name="B" &gt;1&lt;/float&gt; &lt;!-- will be renamed into B2 --&gt;
          &lt;float name="C" &gt;1&lt;/float&gt;
          &lt;float name="D" &gt;1&lt;/float&gt;
        &lt;/data&gt;

        &lt;data filter="keep( {A2 : A, B2 : B} )"&gt;
          &lt;float name="A" &gt;0&lt;/float&gt; &lt;!-- will be renamed into A2 --&gt;
          &lt;float name="B" &gt;1&lt;/float&gt; &lt;!-- will be renamed into B2 --&gt;
          &lt;float name="C" &gt;1&lt;/float&gt; &lt;!-- will be removed --&gt;
          &lt;float name="D" &gt;1&lt;/float&gt; &lt;!-- will be removed --&gt;
        &lt;/data&gt;

        &lt;data filter="rename( {A1 : A, A2 : A, A3: A} )"&gt;
          &lt;float name="A" &gt;0&lt;/float&gt; &lt;!-- will be provided under the names A1, A2 and A3 --&gt;
        &lt;/data&gt;
      </pre>

    </section>
  <section>
    <h3>The compute operator</h3>
    <p>Compute operators can be used to change or create data inside an Xflow graph. They operate like functions, receiving a set of input arguments, doing some work
    and then outputting the result. On <a href="#the-data-element"><code>data</code></a> elements operators may be invoked through the <code>compute</code> attribute
    using the following syntax:</p>

    <pre>
     compute="(output1 [,output2...]) = xflow.[operatorName]([argument1, ...])"
    </pre>

    <p>In <a href="#the-dataflow-element"><code>dataflow</code></a> elements one or more compute operators can be invoked inside a compute block using the
      <a href="#the-dataflow-element"><code>&lt;compute&gt;</code></a> element.</p>

    <p>The fields listed as outputs will be added to the list of data that this data element provides. The arguments must be available to the data element that invokes
    the operator, either as <a href="#value-elements">value elements</a> or provided by a child data element. Compute operators can be invoked in sequence by nesting data
    elements: </p>

    <pre class='example highlight'>
      &lt;data compute="position = xflow.add(position, offset2)"&gt;
        &lt;data compute="position = xflow.add(position, offset1)"&gt;
          &lt;float3 name="position"&gt;...&lt;/float3&gt;
          &lt;float3 name="offset1"&gt;...&lt;/float3&gt;
        &lt;/data&gt;
        &lt;float3 name="offset2"&gt;...&lt;/float3&gt;
      &lt;/data&gt;
    </pre>

    <p>XML3D includes several compute operators by default (a complete list may be found <a href="https://github.com/xml3d/xml3d.js/wiki/Xflow-operator-list">here</a>)
    but also provides an interface to declare custom compute operators. These can be saved in their own JavaScript files and served alongside xml3d.js. Before being used a custom
    operator must be registered with Xflow by calling <code>Xflow.registerOperator</code> with the following syntax:</p>

    <pre class="example highlight">
      Xflow.registerOperator("xflow.myOperatorName", {
        outputs: [ {type: 'float3', name: 'outputName', customAlloc=true },
                   ...
        ],

        params:  [ {type: 'int', source: 'inputName1', optional=true },
                   {type: 'float3', source: 'inputName2', array=true },
                   ...
        ],

        alloc: function(sizes [, inputName1, ...]) {
           // Only necessary if one or more outputs have the flag 'customAlloc=true'
           sizes['outputName'] = inputName2.length;
        },

        evaluate: function(outputName, inputName1, inputName2, info) {
           ...
        }
      });
    </pre>
    <div class="note">As long as a custom operator appears after the <code>xml3d.js</code> script in the document flow the <code>Xflow.registerOperator</code> function can (and should)
      be called immediately. This is typical behavior for a Javascript plugin architecture and ensures the operators have been registered before XML3D initializes the scene (during the
    <code>document.onload</code> event).</div>

    <p>In essence the declaration of the compute operator must contain at least a list of input and output fields, including types, and an <code>evaluate</code> function that is called by
      Xflow during data processing. Input fields may be marked as <code>optional</code>, otherwise they will generate an error if missing.

    </p><p>Output fields may be allocated
      with a custom size, indicated with the <code>customAlloc</code> flag. When this flag is present Xflow will call the <code>alloc</code> function, which should declare the sizes of the
      data arrays that Xflow needs to create for these fields. If a field is not marked with <code>customAlloc</code> then Xflow will attempt to choose the right size based on the inputs to the
      compute operator.
    </p>
    <p>
      Fields marked with the <code>array</code> flag will be provided to the <code>evaluate</code> function as is and will exclude them from the normal length-matching checks that Xflow performs
      on input arguments. This can be used, for example, to pass an array of data with 100 elements while the other input fields all contain thousands of elements. Normally this would generate
      an error as Xflow would not be able to properly iterate through the data.</p>

    <p>The <code>evaluate</code> function will always be called with the list of output fields first, then the input fields, then an <code>info</code> object supplied by Xflow. The <code>info</code>
      object contains information about how the data can be iterated and offers a place to store data during processing:
    </p>

    <pre>
      info = {
        iterFlag: [true|false,...], // Is the input at this position an array that should be iterated over or a single element?
        iterateCount: number,       // The number of elements in the input data to iterate over, ie. (input array length) / (tuple size)
        customData: {}              // A field to hold custom data during and between operator executions
      }
    </pre>
    <div class="note">Fields marked with the <code>array</code> flag will always have an iterFlag value of <code>false</code></div>

    <p>The following is an example operator that uses the <code>info</code> object to iterate over a set of <em>positions</em>, adding a constant <em>offset</em> and returning the
    result as a new array of <em>positions</em>: </p>

    <pre class="example highlight">
      Xflow.registerOperator("xflow.addOffset", {
        outputs: [ {type: 'float3', name: 'result' }
        ],

        params:  [ {type: 'float3', source: 'position' },
                   {type: 'float3', source: 'offset', array=true }
        ],

        evaluate: function(result, position, offset, info) {
           // In this example 'offset' is an array with 3 values (a single float3)
           // 'position' is an array containing thousands of values

           for (var i=0; i < info.iterateCount; i++) {
              result[i*3] = position[ info.iterFlag[0] ? i*3 : 0 ] + offset[0];
              result[i*3+1] = position[ info.iterFlag[0] ? i*3+1 : 1 ] + offset[1];
              result[i*3+1] = position[ info.iterFlag[0] ? i*3+2 : 2 ] + offset[2];
           }
        }
      }
    </pre>


  </section>

  <section>
    <h3>Sequences</h3>
    <p>Xflow allows arbitrarily long sequences of data to be defined using the <code>key</code> attribute on <a href="#value-elements">value elements</a>. This is useful,
      for example, to define the base data for mesh animations to be driven by Xflow <a href="#the-compute-operator">compute operators</a>.
    </p>
    <pre class="example highlight">
      &lt;data id="keyFrameData"&gt;
        &lt;float3 name="position" key="0" &gt;-5 0 5 ... &lt;/float3&gt;
        &lt;float3 name="normal" key="0" &gt;0 -1 0 ... &lt;/float3&gt;

        &lt;float3 name="position" key="0.1" &gt;-2.886751 2.113249 2.886751 ... &lt;/float3&gt;
        &lt;float3 name="normal" key="0.1"&gt;-0.554395 -0.620718 0.554395 ... &lt;/float3&gt;

        &lt;float3 name="position" key="0.2"&gt;-1.341089 4.649148 1.341089 ... &lt;/float3&gt;
        &lt;float3 name="normal" key="0.2"&gt;-0.696886 0.169412 0.696886 ... &lt;/float3&gt;

        &lt;float3 name="position" key="0.3" &gt;-6.158403 1.408833 6.158403 ... &lt;/float3&gt;
        &lt;float3 name="normal" key="0.3"&gt;-0.141341 -0.979819 0.141341 ... &lt;/float3&gt;

        ...
      &lt;/data&gt;
    </pre>
    <p>The above sequence of data represents the keyframes of a mesh animation. Typically a compute operator would then be used to interpolate between keyframes, or to
    otherwise map the sequences of data to a definite set of <code>position</code> and <code>normal</code> data to be rendered.</p>

  </section>


</section>


<section>
    <h2>Content-Types</h2>
    <p>XML3D specifies the following content-types for external resources:</p>
    <pre>
        JSON mesh file     model/vnd.xml3d.mesh+json

        XML mesh file      model/vnd.xml3d.mesh+xml

        XML asset file     model/vnd.xml3d.model+xml

        BLAST binary       model/vnd.xml3d.[model|mesh]+blast
    </pre>
    <p>XML3D will set the appropriate <code>Accept</code> header when requesting these resources. The response should include a
    <code>Content-Type</code> header with the same content-type <b>or</b> the appropriate standard type
    <code>application/json</code>, <code>application/xml</code> or <code>application/octet-stream</code>. </p>
    <div class="note">A response with no <code>Content-Type</code> header at all <em>will not be handled</em> and will generate an error message.</div>
</section>


<section>
  <h2>Events</h2>
    <section>
        <h3>Mouse and Keyboard Events</h3>
        The following event listeners are available on all <a href="#interactive-elements">interactive elements</a>:
            <ul>
                <li>onclick</li>
                <li>ondblclick</li>
                <li>onmousedown</li>
                <li>onmouseup</li>
                <li>onmouseover</li>
                <li>onmousemove</li>
                <li>onmouseout</li>
                <li>onkeypress</li>
                <li>onkeydown</li>
                <li>onkeyup</li>
            </ul>
        The event received by these listeners is a standard HTML5 <a href="http://www.w3.org/TR/DOM-Level-3-Events/#events-mouseevents">MouseEvent</a>
        or <a href="http://www.w3.org/TR/DOM-Level-3-Events/#events-keyboardevents">KeyboardEvent</a> respectively. As in normal HTML, event listeners
        may be added to the element through an appropriate <code>on[eventName]</code> attribute or through JavaScript using <code>element.addEventListener(...)</code>.
        <div class="note">Listeners registered through an attribute must use the following format: <code>"myListenerFunction(event)"</code></div>
    </section>
    <section>
        <h3>FrameDrawn</h3>
        <dl title='interface FrameDrawn : CustomEvent' class='idl'>
            <dt>attribute float detail.timeStart</dt>
            <dd>The system time at the beginning of the frame draw.</dd>
            <dt>attribute float detail.timeEnd</dt>
            <dd>The system time at the end of the frame draw.</dd>
            <dt>attribute float detail.renderTimeInMilliseconds</dt>
            <dd>The total time taken to render this frame. Includes time spent updating the scene state and any XFlow data processing. </dd>
            <dt>attribute int detail.count.objects</dt>
            <dd>The total number of distinct meshes drawn in this frame after applying frustum culling (if enabled).</dd>
            <dt>attribute int detail.count.primitives</dt>
            <dd>The total number of primitives drawn in this frame after applying frustum culling (if enabled).</dd>
        </dl>
    </section>
</section>

</body>
</html>
